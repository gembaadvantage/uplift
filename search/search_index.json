{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Semantic Versioning the Easy Way","text":"<p>By harnessing the power of Conventional Commits, Uplift simplifies the release management of your project through your use of commit messages.</p> <p>Built for Continuous Integration (CI), Uplift is incredibly simple to use, and its modular design allows you to choose which release cycle features you want to incorporate into your workflow. It adheres to the Semantic Versioning specification and plays nicely with other tools.</p> <p>And it's built using Go so that you can install it anywhere!</p>"},{"location":"#features","title":"Features","text":"<ul> <li><code>File Bumping:</code> Update the semantic version within any configured file</li> <li><code>Changelog Generation:</code> Creates and updates a changelog for each semantic release</li> <li><code>Repository Tagging:</code> Tags your repository with the next semantic version</li> </ul> <p>Uplift \u2764\ufe0f Conventional Commits</p>"},{"location":"bumping-files/","title":"Bumping your Files","text":"<p>If you only need to bump the semantic version within specific files, Uplift has you covered. A <code>.uplift.yml</code> configuration file is required for this to work. Bumping files using JSON Paths and Regex are currently supported.</p> <pre><code># .uplift.yml\nbumps:\n- file: package.json\njson:\n- path: \"version\"\nsemver: true\n- file: chart/my-chart/Chart.yaml\nregex:\n- pattern: \"version: $VERSION\"\nsemver: true\ncount: 1\n</code></pre> <pre><code>uplift bump\n</code></pre> <p>Please review our comprehensive guide on configuring file bumps.</p> <p>\u2764\ufe0f to the github.com/tidwall/sjson library.</p>"},{"location":"bumping-files/#glob-support","title":"Glob Support","text":"<p>If you need to bump multiple similar files at the same time, you can specify a file path using a Glob pattern.</p> <pre><code># .uplift.yml\nbumps:\n- file: \"**/package.json\"\njson:\n- path: \"version\"\nsemver: true\n</code></pre> <p>\u2764\ufe0f to the github.com/goreleaser/fileglob library.</p>"},{"location":"bumping-files/#the-version-token","title":"The $VERSION Token","text":"<p>Writing a regex can be challenging at most times, so Uplift provides the <code>$VERSION</code> token for matching a semantic version with an optional <code>v</code> prefix. You can include this in any pattern you define within your config.</p>"},{"location":"bumping-files/#prerelease-support","title":"Prerelease Support","text":"<p> Experimental</p> <p>Uplift has early support for bumping files with prerelease metadata. You will need to calculate this upfront.</p> <pre><code>uplift bump --prerelease beta.1+20220930\n</code></pre>"},{"location":"changelog/","title":"Generating a Changelog","text":"<p>Uplift can generate or amend your repository's changelog (<code>CHANGELOG.md</code>) based on the Keep a Changelog format.</p> <pre><code>uplift changelog\n</code></pre>"},{"location":"changelog/#excluding-commits","title":"Excluding Commits","text":"<p>You can exclude commits from the changelog by specifying a list of regex. Matching against a commit prefix is the most straightforward approach to doing this.</p> <pre><code>uplift changelog --exclude \"^chore,^ci,^test\"\n</code></pre>"},{"location":"changelog/#including-commits","title":"Including Commits","text":"<p>The inverse behaviour is also supported. You can cherry-pick commits by specifying a list of regex. Helpful if you want to generate a changelog for a particular scope of commits.</p> <pre><code>uplift changelog --include \"^.*\\(scope\\)\"\n</code></pre>"},{"location":"changelog/#changing-the-commit-order","title":"Changing the Commit Order","text":"<p>Commits are written to a changelog in descending order, reflecting the behaviour of <code>git log</code>. Change this order by specifying <code>asc</code> (case insensitive).</p> <pre><code>uplift changelog --sort asc\n</code></pre>"},{"location":"changelog/#output-the-changelog-diff","title":"Output the Changelog Diff","text":"<p>You can output the calculated changelog difference (diff) to <code>stdout</code> without modifying the local repository.</p> <pre><code>uplift changelog --diff-only\n</code></pre>"},{"location":"changelog/#migrate-an-existing-repository","title":"Migrate an Existing Repository","text":"<p>If your repository does not contain a <code>CHANGELOG.md</code> file, you can generate one that spans its entire history. A word of warning, this does require a tagging structure to be in place.</p> <pre><code>uplift changelog --all\n</code></pre>"},{"location":"changelog/#supporting-multiline-commits","title":"Supporting Multiline Commits","text":"<p>You can configure <code>uplift</code> to include multiline commit messages within your changelog, by disabling its default behaviour to truncate them to a single line.</p> <pre><code>uplift changelog --multiline\n</code></pre>"},{"location":"commit-signing/","title":"Signing your Commits","text":"<p> Experimental</p> <p>It is best security practice to sign commits with a GPG key to prove their authenticity. Uplift detects the presence of a GPG key through environment variables and will automatically sign any commit.</p> <ul> <li><code>UPLIFT_GPG_KEY</code></li> <li><code>UPLIFT_GPG_PASSPHRASE</code></li> <li><code>UPLIFT_GPG_FINGERPRINT</code></li> </ul>"},{"location":"commit-signing/#generating-a-gpg-key","title":"Generating a GPG Key","text":"<pre><code>gpg --full-generate-key\n</code></pre> <p>Follow the on-screen prompts, selecting <code>RSA and RSA (default)</code> and specifying a key length of <code>4096</code>. Don't forget to use a strong passphrase.</p> <p></p> <p>Take note of the fingerprint, which is <code>FDA7347ACCE12A6CEBED57727B0EDBE188EE9114</code>, in this instance:</p> <p></p>"},{"location":"commit-signing/#exporting-a-gpg-key","title":"Exporting a GPG Key","text":"<p>Please export your GPG key using the <code>ASCII Armor</code> format. Enter your passphrase when prompted.</p> <pre><code>gpg --armor --export-secret-key FDA7347ACCE12A6CEBED57727B0EDBE188EE9114\n</code></pre> <p>You can also <code>base64</code> encode the output:</p> <pre><code>gpg --armor --export-secret-key FDA7347ACCE12A6CEBED57727B0EDBE188EE9114 | base64\n</code></pre>"},{"location":"commit-signing/#limitations","title":"Limitations","text":"<p>Signing-only sub-keys are not supported.</p>"},{"location":"conventional-commits/","title":"Why use Conventional Commits?","text":"<p>Conventional Commits is a specification designed to introduce human and machine-readable meaning to commit messages, enabling automated tooling such as Uplift for managing releases. A user prefixes their commit with a type to describe their intent, and these labels form a direct relationship with Semantic Versioning. The specification adopts the Angular convention, and so does Uplift.</p>"},{"location":"conventional-commits/#semantic-versioning-types","title":"Semantic Versioning Types","text":"<ul> <li><code>fix:</code> A bug fix triggers a patch semantic version bump <code>0.1.0 ~&gt; 0.1.1</code></li> <li><code>feat:</code> A new feature triggers a minor semantic version bump <code>0.1.0 ~&gt; 0.2.0</code></li> <li><code>feat!:</code> A breaking change triggers a major semantic version bump <code>0.1.0 ~&gt; 1.0.0</code><sup>1</sup></li> </ul>"},{"location":"conventional-commits/#additional-angular-types","title":"Additional Angular Types","text":"<p>Uplift supports all the additional Angular types, <code>chore:</code>, <code>ci:</code>, <code>docs:</code>, <code>style:</code>, <code>refactor:</code>, <code>perf:</code> and <code>test:</code>.</p>"},{"location":"conventional-commits/#how-uplift-scans-commits","title":"How Uplift Scans Commits","text":"<p>When determining the next semantic version, all commit messages for a release are scanned for the highest possible increment (Patch, Minor or Major).</p> <pre><code>docs: add documentation for new exciting feature\nci: build and test documentation within pipeline\nfeat: shiny new feature                           &lt;-- largest increment\nfix: fixed another bug found by user\nfix: fixed bug found by user\n</code></pre> <p>In the above example, if the latest tag were <code>0.1.0</code> it would be incremented to <code>0.2.0</code>.</p> <ol> <li> <p>Users can also add a <code>BREAKING CHANGE</code> footer to their commit message.\u00a0\u21a9</p> </li> </ol>"},{"location":"first-release/","title":"Creating your First Release","text":"<p>A release comprises three stages:</p> <ol> <li>Patching the semantic version within a set of configured files (known as file bumping)</li> <li>Generating a changelog</li> <li>Tagging the repository</li> </ol>"},{"location":"first-release/#uplift-configuration","title":"Uplift Configuration","text":"<p>File bumping currently requires a configuration file named <code>.uplift.yml</code>. Please review our guide on configuring file bumps for comprehensive details.</p> <pre><code># .uplift.yml\n# Example of bumping a package.json file\nbumps:\n- file: package.json\njson:\n- path: \"version\"\nsemver: true\n</code></pre> <p>Go, create that release \ud83d\ude80</p> <pre><code>uplift release\n</code></pre>"},{"location":"first-release/#skipping-stages","title":"Skipping Stages","text":"<p>You can skip file bumping <code>--skip-bumps</code> and changelog creation <code>--skip-changelog</code> by using either of the supported flags.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2021-2022 Gemba Advantage</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"tagging/","title":"Tagging your Repository","text":"<p>If you only need to manage the tags on your repository, Uplift has you covered.</p> <pre><code>uplift tag\n</code></pre> <p>If you don't want the <code>v</code> prefix, no problem; remove it by using the <code>--strip-prefix</code> flag.</p>"},{"location":"tagging/#annotated-tags","title":"Annotated Tags","text":"<p> Experimental</p> <p>Lightweight tags are created by default, equivalent to running <code>git tag</code> against your repository. If you need something heavier, such as an annotated tag, modify your configuration file:</p> <pre><code># .uplift.yml\nannotatedTags: true\n</code></pre>"},{"location":"tagging/#prerelease-support","title":"Prerelease Support","text":"<p> Experimental</p> <p>Uplift has early support for tagging a repository with prerelease metadata. You will need to calculate this upfront.</p> <pre><code>uplift tag --prerelease beta.1+20220930\n</code></pre> <p>If you need Uplift to ignore any existing prerelease metadata when calculating the next semantic version, you must include the <code>--ignore-existing-prerelease</code> flag:</p> <pre><code>uplift tag --prerelease beta.1+20221006 --ignore-existing-prerelease\n</code></pre>"},{"location":"uplift-bot/","title":"Your friendly neighbourhood Uplift Bot","text":"<p>Say hi  to the Uplift-Bot, author of all commits and annotated tags within Uplift.</p> <p></p> <p>By default, Uplift commits with the following details:</p> <ul> <li><code>uplift-bot &lt;uplift-bot@gembaadvantage.com&gt;</code></li> <li><code>ci(uplift): uplifted for version v0.1.0</code></li> </ul>"},{"location":"ci/awscodebuild/","title":"AWS CodeBuild","text":"<p>AWS CodeBuild can be used as a standalone service when running Uplift. This guide assumes CodeBuild was configured manually through the AWS Console and focuses on the gotchas<sup>1</sup>.</p> <p>CodeBuild will always receive a git clone with a detached HEAD. By default, Uplift will error in this scenario. When performing a release, this will need to be resolved through a <code>git checkout</code>. The <code>CODEBUILD_SOURCE_VERSION</code> variable contains the necessary git reference.</p>"},{"location":"ci/awscodebuild/#iam","title":"IAM","text":"<p>Additional permissions are needed to pull and push code within AWS CodeBuild. These vary based on the SCM used.</p> <p>Principle of Least Privilege</p> <p>For illustration purposes, a resource type of <code>\"*\"</code> is used. This should always be narrowed to the specific resource when possible.</p>"},{"location":"ci/awscodebuild/#codecommit","title":"CodeCommit","text":"<p>The <code>codecommit:GitPush</code> IAM permission needs to be added. By default, the associated service role will already have the <code>codecommit:GitPull</code> permission.</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Sid\": \"CodeCommitUplift\",\n\"Effect\": \"Allow\",\n\"Action\": [\"codecommit:GitPush\"],\n\"Resource\": \"*\"\n}\n]\n}\n</code></pre>"},{"location":"ci/awscodebuild/#github","title":"GitHub","text":"<p>Permissions are granted through the <code>AWS Connector for GitHub</code> OAuth application from the AWS Console.</p>"},{"location":"ci/awscodebuild/#buildspec","title":"Buildspec","text":"<p>The buildspec can change depending on the base image used by the CodeBuild project.</p>"},{"location":"ci/awscodebuild/#amazon-images","title":"Amazon Images","text":"<p>Tested against the Amazon Linux 2, Ubuntu and Windows variants.</p> <pre><code># buildspec.yml\nversion: 0.2\nenv:\ngit-credential-helper: yes # (1)\nphases:\ninstall:\ncommands:\n- curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash\npre_build:\ncommands:\n- git checkout ${CODEBUILD_SOURCE_VERSION##\"refs/heads/\"} # (2)\nbuild:\ncommands:\n- uplift release\n</code></pre> <ol> <li>Without this Uplift will lack any credentials when attempting to push code back to the source SCM.</li> <li>This can be simplified to <code>git checkout $CODEBUILD_SOURCE_VERSION</code> when cloning from GitHub directly</li> </ol>"},{"location":"ci/awscodebuild/#official-uplift-image","title":"Official Uplift Image","text":"<p>Tested against the public <code>gembaadvantage/uplift</code> image.</p> <p>Dealing with DockerHub Rate Limits</p> <p>There are known issues with accessing public DockerHub repositories from AWS services, documented here.</p> <pre><code># buildspec.yml\nversion: 0.2\nenv:\ngit-credential-helper: yes\nphases:\npre_build:\ncommands:\n- git checkout ${CODEBUILD_SOURCE_VERSION##\"refs/heads/\"}\nbuild:\ncommands:\n- uplift release\n</code></pre>"},{"location":"ci/awscodebuild/#clone-depth","title":"Clone Depth","text":"<p>While configuring a CodeBuild project, the clone depth can be specified. For simplicity, a full clone should be used. If a shallow clone is preferred, you may need to fetch all tags by using the <code>--fetch-all</code> flag.</p> <ol> <li> <p>A preferred approach for generating an AWS CodePipeline would be to either write a CloudFormation template manually or use the AWS CDK tooling. This is known as Infrastructure as Code (IaC), and wasn't included in the documentation to avoid unnecessary complexity.\u00a0\u21a9</p> </li> </ol>"},{"location":"ci/awscodepipeline/","title":"AWS CodePipeline","text":"<p>AWS provides two developer services for building code, <code>AWS CodePipeline</code> and <code>AWS CodeBuild</code>. The former being an orchestration tool, while the later executes each stage using a buildspec file. This guide assumes both were configured manually through the AWS Console and only focuses on the gotchas<sup>1</sup>.</p>"},{"location":"ci/awscodepipeline/#codepipeline","title":"CodePipeline","text":"<p>By default, CodePipeline clones a repository to S3 without the <code>.git</code> metadata folder. A full clone<sup>2</sup> is needed for Uplift to run.</p> <p></p>"},{"location":"ci/awscodepipeline/#codebuild","title":"CodeBuild","text":"<p>CodeBuild will always receive a git clone with a detached HEAD. By default, Uplift will error in this scenario. If performing a release, this will need to be resolved through a <code>git checkout</code>. However, the branch name is not exposed to CodeBuild by default. CodePipeline provides a variable <code>#{SourceVariables.BranchName}</code> that can be mapped to CodeBuild as an environment variable:</p> <p></p>"},{"location":"ci/awscodepipeline/#iam","title":"IAM","text":"<p>Additional permissions are needed to pull and push code within AWS CodeBuild. These vary based on the SCM used.</p> <p>Principle of Least Privilege</p> <p>For illustration purposes, a resource type of <code>\"*\"</code> is used. This should always be narrowed to the specific resource when possible.</p>"},{"location":"ci/awscodepipeline/#codecommit","title":"CodeCommit","text":"<p>Both the <code>codecommit:GitPull</code> and <code>codecommit:GitPush</code> IAM permissions are needed and should be added to the CodeBuild service role.</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Sid\": \"CodeCommitUplift\",\n\"Effect\": \"Allow\",\n\"Action\": [\"codecommit:GitPull\", \"codecommit:GitPush\"],\n\"Resource\": \"*\"\n}\n]\n}\n</code></pre>"},{"location":"ci/awscodepipeline/#github","title":"GitHub","text":"<p>The <code>codestar-connections:UseConnection</code> IAM permission is needed when interacting with GitHub through an AWS CodeStar connection.</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Sid\": \"GitHubUplift\",\n\"Effect\": \"Allow\",\n\"Action\": [\"codestar-connections:UseConnection\"],\n\"Resource\": \"*\"\n}\n]\n}\n</code></pre>"},{"location":"ci/awscodepipeline/#buildspec","title":"Buildspec","text":"<p>The buildspec will change depending on the CodeBuild project base image.</p>"},{"location":"ci/awscodepipeline/#default-amazon-images","title":"Default Amazon Images","text":"<p>Tested against the Amazon Linux 2, Ubuntu and Windows variants.</p> <pre><code># buildspec.yml\nversion: 0.2\nenv:\ngit-credential-helper: yes # (1)\nphases:\ninstall:\ncommands:\n- curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash\npre_build:\ncommands:\n- git checkout $BRANCH_NAME # (2)\nbuild:\ncommands:\n- uplift release\n</code></pre> <ol> <li>Without this Uplift will lack any credentials when attempting to push code back to the source SCM.</li> <li>The <code>BRANCH_NAME</code> environment variable can be referenced directly within the buildspec, once mapped.</li> </ol>"},{"location":"ci/awscodepipeline/#official-uplift-image","title":"Official Uplift Image","text":"<p>Tested against the public <code>gembaadvantage/uplift</code> image.</p> <p>Dealing with DockerHub Rate Limits</p> <p>There are known issues with accessing public DockerHub repositories from AWS services, documented here.</p> <pre><code># buildspec.yml\nversion: 0.2\nenv:\ngit-credential-helper: yes\nphases:\npre_build:\ncommands:\n- git checkout $BRANCH_NAME\nbuild:\ncommands:\n- uplift release\n</code></pre> <ol> <li> <p>A preferred approach for generating an AWS CodePipeline would be to either write a CloudFormation template manually or use the AWS CDK tooling. This is known as Infrastructure as Code (IaC), and wasn't included in the documentation to avoid unnecessary complexity.\u00a0\u21a9</p> </li> <li> <p>This strategy works for all supported SCM providers.\u00a0\u21a9</p> </li> </ol>"},{"location":"ci/circleci/","title":"CircleCI","text":"<p>An example YAML file for configuring Uplift to run on CircleCI. As Uplift is designed to push changes back to your GitHub repository, you will need to ensure CircleCI is granted write access to your repository.</p> <pre><code># .circleci/config.yml\nversion: 2.1\nworkflows:\nmain:\njobs:\n- release:\nfilters:\nbranches:\n# Only trigger on the main branch\nonly: main\njobs:\nrelease:\ndocker:\n# Can use whatever base image you like\n- image: cimg/go:1.18\nsteps:\n# Configure an SSH key that provides write access to your GitHub repository\n- add_ssh_keys:\nfingerprints:\n- \"3b:c7:44:c9:34:ab:a4:fd:6c:33:4e:a7:7a:97:79:55\" # (1)\n- checkout\n# Additional actions specified here\n- run: curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash\n- run: uplift release\n</code></pre> <ol> <li>By default, CircleCI will only have read-only access to your repository. For Uplift to work, write access is required. This can be achieved by accessing a repository as a machine-user and then loading its SSH key into the pipeline by its fingerprint</li> </ol>"},{"location":"ci/cirrusci/","title":"Cirrus CI","text":"<p>An example YAML file for configuring Uplift to run on Cirrus CI. Access to GitHub is managed through their dedicated GitHub Application. As Uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the <code>public_repo</code> permission and added to Cirrus CI as an encrypted variable.</p> <pre><code># .cirrus.yml\ntask:\nname: Release\n# Only run on the main branch\nonly_if: $BRANCH == \"main\" &amp;&amp; $CIRRUS_TAG == \"\"\ncontainer:\nimage: gembaadvantage/uplift:latest\nbefore_script:\n- CLONE_URL=${CIRRUS_REPO_CLONE_URL#\"https://\"}\n- git remote set-url origin \"https://${GITHUB_TOKEN}@${CLONE_URL}\"\nrelease_script:\n- uplift release --fetch-all # (1)\nenvironment:\nGITHUB_TOKEN: ENCRYPTED[!ID!] # (2)\n</code></pre> <ol> <li>As Cirrus CI uses go-git for cloning repositories from GitHub, by default, it doesn't fetch tags. Using the <code>--fetch-all</code> flag with Uplift ensures all tags are pulled before attempting a release</li> <li><code>!ID!</code> should be replaced with the internal ID generated by Cirrus CI. <code>GITHUB_TOKEN</code> can be replaced with any chosen variable name and must be reflected in the remote URL. <code>environment</code> and <code>env</code> are interchangeable.</li> </ol> <p>Uplift publishes docker images that support both amd64 and arm64 architectures, Cirrus CI can be configured to use arm64:</p> <pre><code># .cirrus.yml\ntask:\nname: Release\n# Only run on the main branch\nonly_if: $BRANCH == \"main\" &amp;&amp; $CIRRUS_TAG == \"\"\narm_container:\nimage: gembaadvantage/uplift:latest # (1)\nbefore_script:\n- CLONE_URL=${CIRRUS_REPO_CLONE_URL#\"https://\"}\n- git remote set-url origin \"https://${GITHUB_TOKEN}@${CLONE_URL}\"\nrelease_script:\n- uplift release --fetch-all\nenvironment:\nGITHUB_TOKEN: ENCRYPTED[!ID!]\n</code></pre> <ol> <li>Cirrus CI will seamlessly download the arm64 image from either DockerHub or GHCR through the use of the <code>--platform</code> flag.</li> </ol>"},{"location":"ci/codefresh/","title":"Codefresh","text":"<p>An example YAML file for configuring Uplift to run on Codefresh. To ensure Uplift can push changes back to your repository, you will need to store your Personal Access Token as a shared configuration and expose it to your pipeline as an environment variable, which in this example is <code>GH_UPLIFT</code>.</p> <pre><code># codefresh.yml\nversion: \"1.0\"\nstages:\n- prepare\n- release\nsteps:\nmain_clone: # (1)\ntitle: \"Checkout\"\ntype: git-clone\nrepo: \"${{CF_REPO_OWNER}}/${{CF_REPO_NAME}}\"\nrevision: \"${{CF_BRANCH}}\" # (2)\nstage: prepare\nuplift:\ntitle: \"Release\"\nstage: release\nimage: \"gembaadvantage/uplift\"\ncommands:\n- REMOTE_URL=$(git config --get remote.origin.url)\n- CLONE_URL=${REMOTE_URL#\"https://\"}\n- git remote set-url origin \"https://${GH_UPLIFT}@${CLONE_URL}\"\n- uplift release\n</code></pre> <ol> <li><code>main_clone</code> is a reserved step within Codefresh and is used to simplify the checkout process. A custom checkout can be performed, but you will need to managed the working directory across all other steps.</li> <li>By ensuring the clone is of a specific branch, it prevents the checkout of a detached HEAD.</li> </ol>"},{"location":"ci/drone/","title":"Drone","text":"<p>An example YAML file for configuring Uplift to run on Drone<sup>1</sup>. Instructions for deploying a self-hosted instance of drone can be found here. Uplift requires write permissions to your repository. A Personal Access Token needs to be configured with the <code>public_repo</code> permission and added to Drone as an encrypted secret.</p> <pre><code># .drone.yml\nkind: pipeline\ntype: docker\nname: default\nsteps:\n- name: set-remote\nimage: docker:git\nenvironment:\nGITHUB_PAT:\nfrom_secret: github_pat\ncommands:\n- CLONE_URL=${DRONE_GIT_HTTP_URL##https://}\n- git remote set-url origin https://$GITHUB_PAT@$CLONE_URL\nwhen:\nbranch:\n- main\nevent:\n- push\n- name: release\nimage: gembaadvantage/uplift\ncommands:\n- uplift release --fetch-all # (1)\nwhen:\nbranch:\n- main\nevent:\n- push\n---\nkind: secret\nname: github_pat\ndata: VLO71Ad3QSALQjELGKg5U7r92823a9e4vmu7xUw3LJ9xKwZu8X...\n</code></pre> <ol> <li>Drone does not retrieve any tags by default. Uplift can retrieve all of the latest tags by providing the <code>--fetch-all</code> flag.</li> </ol> <ol> <li> <p>Drone still has a self-hosted offering, but its SaaS product is now integrated with Harness CI.\u00a0\u21a9</p> </li> </ol>"},{"location":"ci/github/","title":"GitHub Action","text":"<p>The official GitHub Action can be used to configure Uplift within your workflow. As Uplift is designed to push changes back to your repository, you will need to provide it with an access token<sup>1</sup>. This is by design.</p> <pre><code># .github/workflows/ci.yml\nname: ci\non:\npush:\nbranches:\n- main\npull_request:\njobs:\nci:\nruns-on: ubuntu-latest\nsteps:\n- name: Checkout\nuses: actions/checkout@v3\nwith:\nfetch-depth: 0 # (1)\n# Additional steps specified here\n- name: Release\nif: github.ref == 'refs/heads/main'\nuses: gembaadvantage/uplift-action@v2.0.1\nwith:\nargs: release\nenv:\nGITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # (2)\n</code></pre> <ol> <li>Setting a <code>fetch-depth</code> of 0 will ensure all tags are retrieved, which is required by Uplift to determine the next semantic version</li> <li>When you use the repository's <code>GITHUB_TOKEN</code> to perform tasks, events triggered by the <code>GITHUB_TOKEN</code> will not create a new workflow run.</li> </ol>"},{"location":"ci/github/#triggering-another-workflow","title":"Triggering another Workflow","text":"<p>To ensure Uplift triggers another workflow run when tagging the repository, a personal access token should be created and stored as a secret. This will then replace the default <code>GITHUB_TOKEN</code> as follows:</p> <pre><code># .github/workflows/ci.yml\nname: ci\non:\npush:\nbranches:\n- main\npull_request:\njobs:\nci:\nruns-on: ubuntu-latest\nsteps:\n- name: Checkout\nuses: actions/checkout@v3\nwith:\nfetch-depth: 0\n# Additional steps specified here\n- name: Release\nif: github.ref == 'refs/heads/main'\nuses: gembaadvantage/uplift-action@v2.0.1\nwith:\nargs: release\nenv:\nGITHUB_TOKEN: ${{ secrets.GH_UPLIFT }}\n</code></pre> <ol> <li> <p>It is best security practice to create an access token with the shortest possible expiration date.\u00a0\u21a9</p> </li> </ol>"},{"location":"ci/gitlab/","title":"GitLab","text":"<p>An example YAML file for configuring Uplift to run on GitLab. To ensure Uplift can push changes back to your repository, you will need to provide it with a project or group access token<sup>1</sup> with the <code>write_repository</code> permission.</p> <pre><code># .gitlab-ci.yml\nstages:\n- release\nrelease:\nstage: release\nimage:\nname: gembaadvantage/uplift\nentrypoint: [\"\"]\ndependencies: [] # (1)\nbefore_script:\n- PROJECT_URL=${CI_PROJECT_URL#\"https://\"}\n- git remote set-url origin \"https://oauth2:${GL_UPLIFT}@${PROJECT_URL}.git\"\nvariables:\n# Disable shallow cloning of repository\nGIT_DEPTH: 0\nscript:\n# GitLab by default checks out a detached HEAD\n- git checkout $CI_COMMIT_REF_NAME\n- uplift release\n# Only run on the default branch of the repository\nrules:\n- if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\nwhen: never\n- if: \"$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\"\nwhen: on_success\n</code></pre> <ol> <li>Prevents any dependencies, such as reports, from being unnecessarily copied into this job and causing the git checks to fail</li> </ol> <p>To expose your access token within your pipeline you should add a CI/CD variable. In the above example, the access token is exposed through the <code>GL_UPLIFT</code> variable.</p> <ol> <li> <p>It is best security practice to create an access token with the shortest possible expiration date.\u00a0\u21a9</p> </li> </ol>"},{"location":"ci/semaphore/","title":"Semaphore","text":"<p>Example YAML files for configuring Uplift to run on Semaphore 2.0. All Semaphore pipelines start with the default file <code>.semaphore/semaphore.yml</code> within your repository. To ensure Uplift is only executed on the <code>main</code> branch, a separate pipeline YAML file is used, triggered by semaphore promotions.</p> <pre><code># .semaphore/semaphore.yml\nversion: v1.0\nname: CI Pipeline\nagent:\nmachine:\ntype: e1-standard-2\nos_image: ubuntu2004\nblocks:\n- name: \"CI\"\ntask:\njobs:\n- name: \"Checkout\"\ncommands:\n- checkout\n# Additional jobs specified here\n# Promotions are used to optionally trigger Uplift on any push to the main branch\npromotions:\n- name: Uplift\npipeline_file: uplift.yml\nauto_promote_on:\n- result: passed\nbranch:\n- main\n</code></pre> <p>A dedicated pipeline installs Uplift and triggers a release:</p> <pre><code># .semaphore/uplift.yml\nversion: \"v1.0\"\nname: Uplift\nagent:\nmachine:\ntype: e1-standard-2\nos_image: ubuntu2004\nblocks:\n- name: \"Release\"\ntask:\nprologue:\ncommands:\n- checkout\njobs:\n- name: uplift\ncommands:\n- curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash\n- uplift release # (1)\n</code></pre> <ol> <li>By default, Semaphore installs a GitHub application that has write access to a list of preselected repositories. This ensures no additional configuration is needed to grant Uplift permissions for pushing changes back to GitHub</li> </ol>"},{"location":"ci/travisci/","title":"Travis CI","text":"<p>An example YAML file for configuring Uplift to run on Travis CI. Access to GitHub is managed through their dedicated GitHub Application. Uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the <code>public_repo</code> permission and added to Travis CI as an encrypted variable.</p> <pre><code># .travis.yml\n# Setup the pipeline based on your chosen language\nlanguage: go\ngit:\ndepth: false\nbefore_install:\n- curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash\nscript:\n- git remote set-url origin https://${GH_UPLIFT}@github.com/${TRAVIS_REPO_SLUG}.git\n- git checkout $TRAVIS_BRANCH\ndeploy:\n- provider: script\nskip_cleanup: true\nscript: uplift release\non:\nbranch: main\ncondition: $TRAVIS_OS_NAME = linux # (1)\nenv:\nglobal:\nsecure: 0l3pSB3Du+YQuV4Gf0R2PoPlrGnmuQhpEbab4KmgUJu6P4S.... # (2)\n</code></pre> <ol> <li>If you have configured Travis CI to use a build matrix, a condition like this should be used to ensure Uplift is only run once.</li> <li>You will need to download Travis in order to encrypt variables. Once downloaded, you must first login <code>travis --login --pro --github-token=&lt;TRAVIS_TOKEN&gt;</code> and then generate an encrypted variable with a command similar to <code>echo GH_UPLIFT=&lt;PERSONAL_ACCESS_TOKEN&gt; | travis encrypt --add --pro</code></li> </ol>"},{"location":"cookbook/push-options/","title":"Configure GitLab pipelines with Push Options","text":"<p>Since Git version <code>2.10</code>, a client could send arbitrary strings to a server (remote) using push options (<code>--push-option</code>). GitLab has utilized push options to configure pipeline behavior since version <code>11.7</code>. This type of configuration opens up many possibilities for configuring your CI/CD workflow through uplift.</p>"},{"location":"cookbook/push-options/#skip-rebuilding-main-branch","title":"Skip Rebuilding Main Branch","text":"<p>During a release, uplift may commit and push some staged files (bumped files and changelog) before tagging the project with the next semantic version. GitLab's default behavior is to spawn two pipelines, one for the main branch and another for the tag. The former may be deemed surplus to requirements and can be skipped using the <code>ci.skip</code> push option:</p> <pre><code>git:\npushOptions:\n- option: ci.skip\nskipTag: true\n</code></pre>"},{"location":"cookbook/push-options/#dynamically-update-cicd-variables","title":"Dynamically update CI/CD Variables","text":"<p>Using environment variables to configure pipelines is a common practice within GitLab. It may be desirable in certain conditions to dynamically change their values, and GitLab provides a <code>ci.variable</code> push option for this exact purpose.</p> <pre><code>git:\npushOptions:\n- option: ci.variable=\"CODE_QUALITY_DISABLED=true\"\nskipBranch: true\n</code></pre>"},{"location":"faq/gitdetached/","title":"Git repository has a detached HEAD","text":"<p>File bumping and changelog creation will not run reliably against a git repository cloned at a specific commit rather than a branch, known as a detached HEAD. Some CI providers use this as an efficient cloning strategy, but it prevents Uplift from pushing changes back to the default branch. If detected, Uplift will report the following error:</p> <pre><code>uplift cannot reliably run when the repository is in a detached HEAD state.\nSome features will not run as expected. To suppress this error, use the\n'--ignore-detached' flag, or set the required config.\n\nFor further details visit: https://upliftci.dev/faq/gitdetached\n</code></pre>"},{"location":"faq/gitdetached/#how-to-fix-it","title":"How to fix it","text":"<p>You can resolve this error in one of two ways.</p>"},{"location":"faq/gitdetached/#reattach-the-head-of-your-repository","title":"Reattach the HEAD of your Repository","text":"<p>Resolving a detached HEAD requires you to check out the default branch, effectively reattaching the HEAD. Please look at our documented CI providers for examples of how to do this.</p>"},{"location":"faq/gitdetached/#suppress-the-error","title":"Suppress the error","text":"<p>You can suppress this error by setting the <code>--ignore-detached</code> flag or by modifying your <code>.uplift.yml</code> config file:</p> <pre><code># .uplift.yml\ngit:\nignoreDetached: true\n</code></pre>"},{"location":"faq/gitdirty/","title":"Git Repository is in a Dirty State","text":"<p>Uplift can't run against a git repository with unstaged or uncommitted files, typically known as a dirty state. If detected, Uplift will report the following error:</p> <pre><code>uplift cannot reliably run if the repository is in a dirty state. Changes detected:\n?? coverage.out\nPlease check and resolve the status of these files before retrying. For further\ndetails visit: https://upliftci.dev/faq/gitdirty\n</code></pre>"},{"location":"faq/gitdirty/#how-to-fix-it","title":"How to fix it","text":"<p>You can resolve this error in one of two ways.</p>"},{"location":"faq/gitdirty/#use-a-gitignore-file","title":"Use a .gitignore file","text":"<p>Add or modify an existing <code>.gitignore</code> file to ignore the offending files listed in the error message.</p>"},{"location":"faq/gitdirty/#adapt-your-ci","title":"Adapt your CI","text":"<ul> <li>Ensure no tracked files are unexpectedly modified</li> <li>Prevent the creation of temporary files. If this isn't possible, you can fall back to using a <code>.gitignore</code> file.</li> </ul>"},{"location":"faq/gitshallow/","title":"Git Repository contains a Shallow Clone","text":"<p>A git repository from a shallow clone will contain a truncated commit history and potentially no previous tags, disabling most, if not all, of the Uplift features. Cloning behaviour will differ between CI providers. If detected, Uplift will report the following error:</p> <pre><code>uplift cannot reliably run against a shallow clone of the repository.\nSome features may not work as expected. To suppress this error, use the\n'--ignore-shallow' flag, or set the required config.\n\nFor further details visit: https://upliftci.dev/faq/gitshallow\n</code></pre>"},{"location":"faq/gitshallow/#how-to-fix-it","title":"How to fix it","text":"<p>You can resolve this error in one of three ways.</p>"},{"location":"faq/gitshallow/#fetch-the-history","title":"Fetch the history","text":"<p>If no history exists, use the <code>--</code> flag...</p>"},{"location":"faq/gitshallow/#fetch-the-tags","title":"Fetch the tags","text":"<p>If no tags exist, use the <code>--fetch-tags</code> flag to fetch all tags from the origin.</p>"},{"location":"faq/gitshallow/#suppress-the-error","title":"Suppress the error","text":"<p>You can suppress this error by setting the <code>--ignore-shallow</code> flag or by modifying your <code>.uplift.yml</code> config file:</p> <pre><code># .uplift.yml\ngit:\nignoreShallow: true\n</code></pre>"},{"location":"faq/gpgimport/","title":"GPG Key fails to Import","text":"<p>Uplift supports the signing of commits by importing a GPG key and correctly configuring git. Your GPG key needs to be exported in the ASCII Armor Format (optionally base64 encoded) for this to work. Uplift will report the following error:</p> <pre><code>uplift could not import GPG key with fingerprint FDA7347ACCE12A6CEBED57727B0EDBE188EE9114.\nCheck your GPG key was exported correctly.\n\nFor further details visit: https://upliftci.dev/faq/gpgimport\n</code></pre>"},{"location":"faq/gpgimport/#how-to-fix-it","title":"How to fix it","text":"<p>You can resolve this error by exporting your key using the <code>--armor</code> flag. Please read the following guide on how to do this.</p>"},{"location":"install/binary/","title":"Installing the Binary","text":"<p>You can use various package managers to install the Uplift binary. Take your pick.</p>"},{"location":"install/binary/#package-managers","title":"Package Managers","text":""},{"location":"install/binary/#homebrew","title":"Homebrew","text":"<p>To use Homebrew:</p> <pre><code>brew install gembaadvantage/tap/uplift\n</code></pre>"},{"location":"install/binary/#scoop","title":"Scoop","text":"<p>To use Scoop:</p> <pre><code>scoop install uplift\n</code></pre>"},{"location":"install/binary/#apt","title":"Apt","text":"<p>To install using the apt package manager:</p> <pre><code>echo 'deb [trusted=yes] https://fury.upliftci.dev/apt/ /' | sudo tee /etc/apt/sources.list.d/uplift.list\nsudo apt update\nsudo apt install -y uplift\n</code></pre> <p>You may need to install the <code>ca-certificates</code> package if you encounter trust issues with regards to the Gemfury certificate:</p> <pre><code>sudo apt update &amp;&amp; sudo apt install -y ca-certificates\n</code></pre>"},{"location":"install/binary/#yum","title":"Yum","text":"<p>To install using the yum package manager:</p> <pre><code>echo '[uplift]\nname=uplift\nbaseurl=https://fury.upliftci.dev/yum/\nenabled=1\ngpgcheck=0' | sudo tee /etc/yum.repos.d/uplift.repo\nsudo yum install -y uplift\n</code></pre>"},{"location":"install/binary/#aur","title":"Aur","text":"<p>To install from the aur using yay:</p> <pre><code>yay -S uplift-bin\n</code></pre>"},{"location":"install/binary/#linux-packages","title":"Linux Packages","text":"<p>Download and manually install one of the <code>.deb</code>, <code>.rpm</code> or <code>.apk</code> packages from the Releases page.</p> AptYumApk <pre><code>sudo apt install uplift_*.deb\n</code></pre> <pre><code>sudo yum localinstall uplift_*.rpm\n</code></pre> <pre><code>sudo apk add --no-cache --allow-untrusted uplift_*.apk\n</code></pre>"},{"location":"install/binary/#bash-script","title":"Bash Script","text":"<p>To install the latest version using a bash script:</p> <pre><code>curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash\n</code></pre> <p>Download a specific version using the <code>-v</code> flag. The script uses <code>sudo</code> by default but can be disabled through the <code>--no-sudo</code> flag.</p> <pre><code>curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash -s -- -v v2.6.3 --no-sudo\n</code></pre>"},{"location":"install/binary/#manual-download-of-binary","title":"Manual Download of Binary","text":"<p>Binary downloads of uplift can be found on the Releases page. Unpack the uplift binary and add it to your <code>PATH</code>.</p>"},{"location":"install/binary/#verifying-a-binary-with-cosign","title":"Verifying a Binary with Cosign","text":"<p>All binaries can be verified using cosign.</p> <ol> <li> <p>Download the checksum files that need to be verified:    <pre><code>curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt -O\ncurl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt.sig -O\ncurl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt.pem -O\n</code></pre></p> </li> <li> <p>Verify the signature of the checksum file:    <pre><code>cosign verify-blob --cert checksums.txt.pem --signature checksums.txt.sig checksums.txt\n</code></pre></p> </li> <li> <p>Download any release artefact and verify its SHA256 signature matches the entry within the checksum file:    <pre><code>sha256sum --ignore-missing -c checksums.txt\n</code></pre></p> </li> </ol>"},{"location":"install/docker/","title":"Running with Docker","text":"<p>You can run Uplift directly from a docker image. Just mount your repository as a volume and set it as the working directory. \ud83d\udc33</p> DockerHubGHCR <pre><code>docker run --rm -v $PWD:/tmp -w /tmp gembaadvantage/uplift release\n</code></pre> <pre><code>docker run --rm -v $PWD:/tmp -w /tmp ghcr.io/gembaadvantage/uplift release\n</code></pre>"},{"location":"install/docker/#verifying-with-cosign","title":"Verifying with Cosign","text":"<p>Docker images can be verified using cosign.</p> DockerHubGHCR <pre><code>COSIGN_EXPERIMENTAL=1 cosign verify gembaadvantage/uplift\n</code></pre> <pre><code>COSIGN_EXPERIMENTAL=1 cosign verify ghcr.io/gembaadvantage/uplift\n</code></pre>"},{"location":"install/oh-my-zsh/","title":"Install the Oh My Zsh Plugin","text":"<p>Get all the extra autocompletion goodness with Oh My Zsh.</p> <pre><code>git clone https://github.com/gembaadvantage/uplift-oh-my-zsh ~/.oh-my-zsh/plugins/uplift\n</code></pre> <p>Enable it within your <code>~/.zshrc</code> file:</p> <pre><code>plugins=(... uplift)\n</code></pre> <p>Fin!</p>"},{"location":"install/source/","title":"Compiling from Source","text":"<p>Download both Go 1.19+ and go-task. Then clone the code from GitHub:</p> <pre><code>git clone https://github.com/gembaadvantage/uplift.git\ncd uplift\n</code></pre> <p>Build:</p> <pre><code>task\n</code></pre> <p>And check that everything works:</p> <pre><code>./uplift version\n</code></pre>"},{"location":"reference/config/","title":"Uplift Configuration","text":"<p>You are free to control Uplift through the use of a dedicated configuration file. A variety of different naming conventions are supported:</p> <ul> <li><code>.uplift.yml</code></li> <li><code>.uplift.yaml</code></li> <li><code>uplift.yml</code></li> <li><code>uplift.yaml</code></li> </ul>"},{"location":"reference/config/#annotatedtags","title":"annotatedTags","text":"<pre><code># Use annotated tags instead of lightweight tags when tagging a new\n# semantic version. An annotated tag is treated like a regular commit\n# by git and contains both author details and a commit message. Uplift\n# will either use its defaults or the custom commit details provided\n# when generated the annotated tag.\n#\n# Defaults to false\nannotatedTags: true\n</code></pre>"},{"location":"reference/config/#bumps","title":"bumps","text":"<pre><code># Define a series of files whose semantic version will be bumped.\n# Supports both Regex and JSON Path based file bumps\n#\n# Defaults to no files being bumped\nbumps:\n# The path of the file relative to where Uplift is executed. Glob\n# patterns can be used to match multiple files at the same time\n- file: package.json\n# A JSON path matcher should be used when bumping the file. Multiple\n# path matches are supported. Each will be carried out in the order\n# they are defined here. All matches must succeed for the file to\n# be bumped. JSON path syntax is based on\n# https://github.com/tidwall/sjson\n#\n# Defaults to no matchers\njson:\n# A JSON path that will be used for matching the version that\n# will be replaced within the file\n- path: \"version\"\n# If the matched version in the file should be replaced with a\n# semantic version. This will strip any 'v' prefix if needed\n#\n# Defaults to false\nsemver: true\n# The path of the file relative to where Uplift is executed. Glob\n# patterns can be used to match multiple files at the same time\n- file: chart/my-chart/Chart.yaml\n# A regex matcher should be used when bumping the file. Multiple\n# regex matches are supported. Each will be carried out in the order\n# they are defined here. All matches must succeed for the file to\n# be bumped\n#\n# Defaults to no matchers\nregex:\n# The regex that should be used for matching the version that\n# will be replaced within the file\n- pattern: \"version: $VERSION\"\n# If the matched version in the file should be replaced with a\n# semantic version. This will strip any 'v' prefix if needed\n#\n# Defaults to false\nsemver: true\n# The number of times any matched version should be replaced\n#\n# Defaults to 0, which replaces all matches\ncount: 1\n</code></pre>"},{"location":"reference/config/#changelog","title":"changelog","text":"<pre><code># Customise the creation of the Changelog\nchangelog:\n# Change the sort order of the commits within each changelog entry.\n# Supported values are asc or desc (case is ignored)\n#\n# Defaults to desc (descending order) to mirror the default behaviour\n# of \"git log\"\nsort: asc\n# A list of commits to exclude during the creation of a changelog.\n# Provide a list of regular expressions for matching commits that\n# are to be excluded. Auto-generated commits from Uplift\n# (with the prefix ci(uplift)) will always be excluded\n#\n# Defaults to an empty list. All commits are included\nexclude:\n- '^chore\\(deps\\)'\n- ^docs\n- ^ci\n# A list of commits to cherry-pick and include during the creation\n# of a changelog. Provide a list of regular expressions for matching\n# commits that are to be included\ninclude:\n- '^.*\\(scope\\)'\n# Include multiline commit messages within the changelog. Disables\n# default behaviour of truncating a commit message to its first line\nmultiline: true\n</code></pre>"},{"location":"reference/config/#commitauthor","title":"commitAuthor","text":"<pre><code># Changes the commit author used by Uplift when committing any staged\n# changes.\n#\n# Defaults to the Uplift Bot: uplift-bot &lt;uplift@gembaadvantage.com&gt;\ncommitAuthor:\n# Name of the author\n#\n# Defaults to the author name within the last commit\nname: \"joe.bloggs\"\n# Email of the author\n#\n# Defaults to the author email within the last commit\nemail: \"joe.bloggs@gmail.com\"\n</code></pre>"},{"location":"reference/config/#commitmessage","title":"commitMessage","text":"<pre><code># Changes the default commit message used by Uplift when committing\n# any staged changes.\n#\n# Default commit message is: ci(uplift): uplifted for version v0.1.0\ncommitMessage: \"chore(release): this is a custom release message\"\n</code></pre>"},{"location":"reference/config/#hooks","title":"hooks","text":"<pre><code># All hooks default to an empty list and will be skipped\nhooks:\n# A list of shell commands or scripts to execute before Uplift runs\n# any tasks within any workflow\nbefore:\n- cargo fetch\n- ENV=VALUE ./my-custom-script.sh\n- bash path//to//my-custom-script.sh # (1)\n# A list of shell commands or scripts to execute before Uplift bumps\n# any configured file\nbeforeBump:\n- echo \"Before Bump\"\n# A list of shell commands or scripts to execute before Uplift runs\n# its changelog generation task\nbeforeChangelog:\n- echo \"Before Changelog\"\n# A list of shell commands or scripts to execute before Uplift tags\n# the repository with the next semantic release\nbeforeTag:\n- echo \"Before Tag\"\n# A list of shell commands or scripts to execute after Uplift\n# completes all tasks within any workflow\nafter:\n- echo \"After Workflow\"\n# A list of shell commands or scripts to execute after Uplift bumps\n# any configured file\nafterBump:\n- echo \"After Bump\"\n# A list of shell commands or scripts to execute after Uplift generates\n# a new changelog\nafterChangelog:\n- echo \"After Changelog\"\n# A list of shell commands or scripts to execute after Uplift tags\n# the repository with the next semantic release\nafterTag:\n- echo \"After Tag\"\n</code></pre> <ol> <li>An example of using POSIX-based windows commands is through the mvdan/sh GitHub library. Pay special attention to the use of <code>//</code> when specifying a path</li> </ol>"},{"location":"reference/config/#env","title":"env","text":"<pre><code># Define a set of environment variables that are made available to all\n# hooks. Supports loading environment variables from DotEnv (.env)\n# files. Environment variables are merged with system wide ones.\nenv:\n- VARIABLE=VALUE\n- ANOTHER_VARIABLE=ANOTHER VALUE\n- .env\n- path/to/other.env\n</code></pre>"},{"location":"reference/config/#git","title":"git","text":"<pre><code># Customise how Uplift interacts with Git\ngit:\n# A flag for suppressing the git detached HEAD repository check. If set\n# to true, Uplift will report a warning while running, otherwise Uplift\n# will raise an error and stop.\n#\n# Defaults to false\nignoreDetached: true\n# A flag for suppressing the git shallow repository check. If set to\n# true, Uplift will report a warning while running, otherwise Uplift\n# will raise an error and stop.\n#\n# Defaults to false\nignoreShallow: true\n# An array of Git push options that can be independently configured\n# for both branch and tag operations within Uplift. Provided options\n# will be filtered accordingly and appended to the git push operation\n# through the use of the --push-option flag as documented in\n# https://git-scm.com/docs/git-push#Documentation/git-push.txt\n#\n# Defaults to any empty array\npushOptions:\n- ci.skip\n# For more fine-grained control, a push option can be skipped\n# based on the type of push being executed\n- option: ci.variable=\"MAX_RETRIES=10\"\nskipTag: true\nskipBranch: false\n</code></pre>"},{"location":"reference/config/#gitea","title":"gitea","text":"<pre><code># Add support for Gitea SCM detection\ngitea:\n# The URL of the self-hosted instance of Gitea. Only the scheme and\n# hostname are required. The hostname is used when matching against\n# the configured remote origin of the cloned repository\n#\n# Defaults to empty string i.e. no detection is supported\nurl: https://my.gitea.com\n</code></pre>"},{"location":"reference/config/#github","title":"github","text":"<pre><code># Add support for GitHub SCM detection\ngithub:\n# The URL of the enterprise instance of GitHub. Only the scheme and\n# hostname are required. The hostname is used when matching against\n# the configured remote origin of the cloned repository\n#\n# Defaults to empty string i.e. no detection is supported\nurl: https://my.github.com\n</code></pre>"},{"location":"reference/config/#gitlab","title":"gitlab","text":"<pre><code># Add support for GitLab SCM detection\ngitlab:\n# The URL of the self-managed instance of GitLab. Only the scheme and\n# hostname are required. The hostname is used when matching against\n# the configured remote origin of the cloned repository\n#\n# Defaults to empty string i.e. no detection is supported\nurl: https://my.gitlab.com\n</code></pre>"},{"location":"reference/cli/bump/","title":"Command Line","text":"<pre><code>Calculates the next semantic version based on the conventional commits since the\nlast release (or identifiable tag) and bumps (or patches) a configurable set of\nfiles with said version. JSON Path or Regex Pattern matching is supported when\nscanning files for an existing semantic version. Uplift automatically handles\nthe staging and pushing of modified files to the git remote, but this behavior\ncan be disabled, to manage this action manually.\n\nConfiguring a bump requires an Uplift configuration file to exist within the\nroot of your project:\n\nhttps://upliftci.dev/bumping-files/\n</code></pre>"},{"location":"reference/cli/bump/#usage","title":"Usage","text":"<pre><code>uplift bump [flags]\n</code></pre>"},{"location":"reference/cli/bump/#examples","title":"Examples","text":"<pre><code># Bump (patch) all configured files with the next calculated semantic version\nuplift bump\n\n# Append a prerelease suffix to the next calculated semantic version\nuplift bump --prerelease beta.1\n\n# Bump (patch) all configured files but do not stage or push any changes\n# back to the git remote\nuplift bump --no-stage\n</code></pre>"},{"location":"reference/cli/bump/#flags","title":"Flags","text":"<pre><code>-h, --help                help for bump\n    --prerelease string   append a prerelease suffix to next calculated\n                          semantic version\n</code></pre>"},{"location":"reference/cli/bump/#global-flags","title":"Global Flags","text":"<pre><code>--config-dir string            a custom path to a directory containing uplift\n                               config (default \".\")\n--debug                        show me everything that happens\n--dry-run                      run without making any changes\n--ignore-detached              ignore reported git detached HEAD error\n--ignore-existing-prerelease   ignore any existing prerelease when calculating\n                               next semantic version\n--ignore-shallow               ignore reported git shallow clone error\n--no-push                      no changes will be pushed to the git remote\n--no-stage                     no changes will be git staged\n--silent                       silence all logging\n</code></pre>"},{"location":"reference/cli/changelog/","title":"Command Line","text":"<pre><code>Scans the git log for the latest semantic release and generates a changelog\nentry. If this is a first release, all commits between the last release (or\nidentifiable tag) and the repository trunk will be written to the changelog.\nAny subsequent entry within the changelog will only contain commits between\nthe latest set of tags. Basic customization is supported. Optionally commits\ncan be explicitly included or excluded from the entry and sorted in ascending\nor descending order. Uplift automatically handles the staging and pushing of\nchanges to the CHANGELOG.md file to the git remote, but this behavior can be\ndisabled, to manage this action manually.\n\nUplift bases its changelog format on the Keep a Changelog specification:\n\nhttps://keepachangelog.com/en/1.0.0/\n</code></pre>"},{"location":"reference/cli/changelog/#usage","title":"Usage","text":"<pre><code>uplift changelog [flags]\n</code></pre>"},{"location":"reference/cli/changelog/#examples","title":"Examples","text":"<pre><code># Generate the next changelog entry for the latest semantic release\nuplift changelog\n\n# Generate a changelog for the entire history of the repository\nuplift changelog --all\n\n# Generate the next changelog entry and write it to stdout\nuplift changelog --diff-only\n\n# Generate the next changelog entry by exclude any conventional commits\n# with the ci, chore or test prefixes\nuplift changelog --exclude \"^ci,^chore,^test\"\n\n# Generate the next changelog entry with commits that only include the\n# following scope\nuplift changelog --include \"^.*\\(scope\\)\"\n\n# Generate the next changelog entry but do not stage or push any changes\n# back to the git remote\nuplift changelog --no-stage\n\n# Generate a changelog with multiline commit messages\nuplift changelog --multiline\n</code></pre>"},{"location":"reference/cli/changelog/#flags","title":"Flags","text":"<pre><code>    --all               generate a changelog from the entire history of this\n                        repository\n    --diff-only         output the changelog diff only\n    --exclude strings   a list of regexes for excluding conventional commits\n                        from the changelog\n-h, --help              help for changelog\n    --include strings   a list of regexes to cherry-pick conventional commits\n                        for the changelog\n    --multiline         include multiline commit messages within changelog\n                        (skips truncation)\n    --sort string       the sort order of commits within each changelog entry\n</code></pre>"},{"location":"reference/cli/changelog/#global-flags","title":"Global Flags","text":"<pre><code>--config-dir string            a custom path to a directory containing uplift\n                               config (default \".\")\n--debug                        show me everything that happens\n--dry-run                      run without making any changes\n--ignore-detached              ignore reported git detached HEAD error\n--ignore-existing-prerelease   ignore any existing prerelease when calculating\n                               next semantic version\n--ignore-shallow               ignore reported git shallow clone error\n--no-push                      no changes will be pushed to the git remote\n--no-stage                     no changes will be git staged\n--silent                       silence all logging\n</code></pre>"},{"location":"reference/cli/release/","title":"Command Line","text":"<pre><code>Release the next semantic version of your git repository. A release consists of\na three-stage process. First, all configured files will be bumped (patched)\nusing the next semantic version. Second, a changelog entry containing all\ncommits for the latest semantic release will be created. Finally, Uplift will\ntag the repository. Uplift automatically handles the staging and pushing of\nmodified files and the tagging of the repository with two separate git pushes.\nBut this behavior can be disabled to manage these actions manually.\n\nParts of this release process can be disabled if needed.\n\nhttps://upliftci.dev/first-release/\n</code></pre>"},{"location":"reference/cli/release/#usage","title":"Usage","text":"<pre><code>uplift release [flags]\n</code></pre>"},{"location":"reference/cli/release/#examples","title":"Examples","text":"<pre><code># Release the next semantic version\nuplift release\n\n# Release the next semantic version without bumping any files\nuplift release --skip-bumps\n\n# Release the next semantic version without generating a changelog\nuplift release --skip-changelog\n\n# Append a prerelease suffix to the next calculated semantic version\nuplift release --prerelease beta.1\n\n# Ensure any \"v\" prefix is stripped from the next calculated semantic\n# version to explicitly adhere to the SemVer specification\nuplift release --no-prefix\n</code></pre>"},{"location":"reference/cli/release/#flags","title":"Flags","text":"<pre><code>    --check               check if a release will be triggered\n    --exclude strings     a list of regexes for excluding conventional commits\n                          from the changelog\n    --fetch-all           fetch all tags from the remote repository\n-h, --help                help for release\n    --include strings     a list of regexes to cherry-pick conventional commits\n                          for the changelog\n    --multiline           include multiline commit messages within changelog\n                          (skips truncation)\n    --no-prefix           strip the default 'v' prefix from the next calculated\n                          semantic version\n    --prerelease string   append a prerelease suffix to next calculated semantic\n                          version\n    --skip-bumps          skips the bumping of any files\n    --skip-changelog      skips the creation or amendment of a changelog\n    --sort string         the sort order of commits within each changelog entry\n</code></pre>"},{"location":"reference/cli/release/#global-flags","title":"Global Flags","text":"<pre><code>--config-dir string            a custom path to a directory containing uplift\n                               config (default \".\")\n--debug                        show me everything that happens\n--dry-run                      run without making any changes\n--ignore-detached              ignore reported git detached HEAD error\n--ignore-existing-prerelease   ignore any existing prerelease when calculating\n                               next semantic version\n--ignore-shallow               ignore reported git shallow clone error\n--no-push                      no changes will be pushed to the git remote\n--no-stage                     no changes will be git staged\n--silent                       silence all logging\n</code></pre>"},{"location":"reference/cli/root/","title":"Command Line","text":"<pre><code>Semantic versioning the easy way.\n</code></pre>"},{"location":"reference/cli/root/#usage","title":"Usage","text":"<pre><code>uplift [command]\n</code></pre>"},{"location":"reference/cli/root/#flags","title":"Flags","text":"<pre><code>    --config-dir string            a custom path to a directory containing\n                                   uplift config (default \".\")\n    --debug                        show me everything that happens\n    --dry-run                      run without making any changes\n-h, --help                         help for uplift\n    --ignore-detached              ignore reported git detached HEAD error\n    --ignore-existing-prerelease   ignore any existing prerelease when\n                                   calculating next semantic version\n    --ignore-shallow               ignore reported git shallow clone error\n    --no-push                      no changes will be pushed to the git remote\n    --no-stage                     no changes will be git staged\n    --silent                       silence all logging\n</code></pre>"},{"location":"reference/cli/root/#commands","title":"Commands","text":"<pre><code>bump        Bump the semantic version within files\nchangelog   Create or update a changelog with the latest semantic release\ncompletion  Generate completion script for your target shell\nhelp        Help about any command\nrelease     Release the next semantic version of a repository\ntag         Tag a git repository with the next semantic version\nversion     Prints the build time version information\n</code></pre>"},{"location":"reference/cli/tag/","title":"Command Line","text":"<pre><code>Generates a new git tag by scanning the git log of a repository for any\nconventional commits since the last release (or identifiable tag). When\nexamining the git log, Uplift will always calculate the next semantic version\nbased on the most significant detected increment. Uplift automatically handles\nthe creation and pushing of a new git tag to the remote, but this behavior can\nbe disabled, to manage this action manually.\n\nConventional Commits is a set of rules for creating an explicit commit history,\nwhich makes building automation tools like Uplift much easier. Uplift adheres to\nv1.0.0 of the specification:\n\nhttps://www.conventionalcommits.org/en/v1.0.0\n</code></pre>"},{"location":"reference/cli/tag/#usage","title":"Usage","text":"<pre><code>uplift tag [flags]\n</code></pre>"},{"location":"reference/cli/tag/#examples","title":"Examples","text":"<pre><code># Tag the repository with the next calculated semantic version\nuplift tag\n\n# Identify the next semantic version and write to stdout. Repository is\n# not tagged\nuplift tag --next --silent\n\n# Identify the current semantic version and write to stdout. Repository\n# is not tagged\nuplift tag --current\n\n# Identify the current and next semantic versions and write both to stdout.\n# Repository is not tagged\nuplift tag --current --next --silent\n\n# Ensure the calculated version explicitly aheres to the SemVer specification\n# by stripping the \"v\" prefix from the generated tag\nuplift tag --no-prefix\n\n# Append a prerelease suffix to the next calculated semantic version\nuplift tag --prerelease beta.1\n\n# Tag the repository with the next calculated semantic version, but do not\n# push the tag to the remote\nuplift tag --no-push\n</code></pre>"},{"location":"reference/cli/tag/#flags","title":"Flags","text":"<pre><code>    --current             output the current tag\n    --fetch-all           fetch all tags from the remote repository\n-h, --help                help for tag\n    --next                output the next tag\n    --no-prefix           strip the default 'v' prefix from the next calculated\n                          semantic version\n    --prerelease string   append a prerelease suffix to next calculated semantic\n                          version\n</code></pre>"},{"location":"reference/cli/tag/#global-flags","title":"Global Flags","text":"<pre><code>--config-dir string            a custom path to a directory containing uplift\n                               config (default \".\")\n--debug                        show me everything that happens\n--dry-run                      run without making any changes\n--ignore-detached              ignore reported git detached HEAD error\n--ignore-existing-prerelease   ignore any existing prerelease when calculating\n                               next semantic version\n--ignore-shallow               ignore reported git shallow clone error\n--no-push                      no changes will be pushed to the git remote\n--no-stage                     no changes will be git staged\n--silent                       silence all logging\n</code></pre>"},{"location":"scm/about/","title":"SCM Detection","text":"<p> Experimental</p> <p>Uplift uses SCM (source code management) detection to identify repositories from GitHub, GitLab, CodeCommit and Gitea (pronounced git-tea). From this detection, Uplift provides the following features:</p> <ul> <li>Dynamic links within changelogs</li> </ul> <p>Keep an eye on this space</p> <p>More features will be added as Uplift dives more into this space</p>"},{"location":"scm/gitea/","title":"Gitea","text":"<p>As Gitea is a self-hosted SCM, custom configuration is required to support detection.</p> <pre><code># uplift.yml\n# Add support for Gitea SCM detection\ngitea:\n# The URL of the self-hosted instance of Gitea. Only the scheme and\n# hostname are required. The hostname is used when matching against\n# the configured remote origin of the cloned repository\n#\n# Defaults to empty string i.e. no detection is supported\nurl: https://my.gitea.com\n</code></pre>"},{"location":"scm/github/","title":"GitHub","text":"<p>Uplift comes with built-in detection for GitHub (SaaS). However, when using GitHub Enterprise, custom configuration is needed.</p> <pre><code># uplift.yml\n# Add support for GitHub SCM detection\ngithub:\n# The URL of the enterprise instance of GitHub. Only the scheme and\n# hostname are required. The hostname is used when matching against\n# the configured remote origin of the cloned repository\n#\n# Defaults to empty string i.e. no detection is supported\nurl: https://my.github.com\n</code></pre>"},{"location":"scm/gitlab/","title":"GitLab","text":"<p>Uplift comes with built-in detection for GitLab (SaaS). However, when using Self-Managed GitLab, custom configuration is needed.</p> <pre><code># uplift.yml\n# Add support for GitLab SCM detection\ngitlab:\n# The URL of the self-managed instance of GitLab. Only the scheme and\n# hostname are required. The hostname is used when matching against\n# the configured remote origin of the cloned repository\n#\n# Defaults to empty string i.e. no detection is supported\nurl: https://my.gitlab.com\n</code></pre>"},{"location":"setup/commit-details/","title":"Changing the Commit Details","text":"<p>If you don't want to use the default commit from the Uplift-Bot, you are free to replace both the author and commit message with anything you like:</p> <pre><code>commitAuthor:\nname: \"joe.bloggs\"\nemail: \"joe.bloggs@gmail.com\"\ncommitMessage: \"chore(release): a custom release message\"\n</code></pre> <p>Uplift uses your GPG Identity</p> <p>If you have imported a GPG key, Uplift will always use the keys user identity over any other configuration</p>"},{"location":"setup/config-location/","title":"Changing the default Config Location","text":"<p>Uplift will look for a config file in the root of your repository. If you wish to change this location, you can use the <code>--config-dir</code> flag.</p> <pre><code>uplift release --config-dir .github\n</code></pre>"},{"location":"setup/dry-run/","title":"Run Uplift without making any Changes","text":"<p>New to Uplift? Want to understand how it works?</p> <p>Then you have come to the right place. Use the <code>--dry-run</code> flag with any command and Uplift will run in simulation mode and output precisely what would have changed.</p> <pre><code>uplift release --dry-run\n</code></pre> <p>If you want extra information, turn on debug mode with the <code>--debug</code> flag.</p>"},{"location":"setup/git-behaviour/","title":"Changing how Uplift works with Git","text":"<p>Git is the core component behind Uplift. So it is only fitting that Uplift supports customisation options when interacting with it.</p>"},{"location":"setup/git-behaviour/#skipping-git-checks","title":"Skipping Git Checks","text":"<p>Sometimes Uplift will complain about the state of the current git repository. If you wish to override this behaviour, you can customise how Uplift interacts with git. It is worth pointing out that you cannot make Uplift run against a dirty repository, and you will have to fix that yourself using our handy FAQ</p>"},{"location":"setup/git-behaviour/#ignoring-a-detached-head","title":"Ignoring a Detached HEAD","text":"<p>Either use the <code>--ignore-detached</code> flag:</p> <pre><code>uplift release --ignore-detached\n</code></pre> <p>Or include the following entry in your config file:</p> <pre><code># .uplift.yml\ngit:\nignoreDetached: true\n</code></pre>"},{"location":"setup/git-behaviour/#ignoring-a-shallow-clone","title":"Ignoring a Shallow Clone","text":"<p>Either use the <code>--ignore-shallow</code> flag:</p> <pre><code>uplift release --ignore-shallow\n</code></pre> <p>Or include the following entry in your config file:</p> <pre><code># .uplift.yml\ngit:\nignoreShallow: true\n</code></pre>"},{"location":"setup/git-behaviour/#additional-git-push-options","title":"Additional Git Push Options","text":"<p>Since Git version 2.10, the ability to pass additional push options (<code>--push-option</code>) to the remote has been supported. Some SCMs have used this to support custom behaviour after a push. By including the following entry in your config file, Uplift can use these options independently during a push of staged files and a push of a new tag.</p> <pre><code># .uplift.yml\ngit:\npushOptions:\n- option: ci.skip\nskipBranch: true\nskipTag: false\n</code></pre>"},{"location":"setup/git-behaviour/#prevent-staging-of-files","title":"Prevent Staging of Files","text":"<p>To take ownership of staging and committing files to your repository, you can disable this automatic feature within Uplift using the <code>--no-stage</code> flag.</p> <pre><code>uplift release --no-stage\n</code></pre>"},{"location":"setup/git-behaviour/#prevent-pushing-changes-to-the-remote","title":"Prevent Pushing Changes to the Remote","text":"<p>To take ownership of pushing changes to your repository, you can disable this automatic feature within Uplift with the <code>--no-push</code> flag.</p> <pre><code>uplift release --no-push\n</code></pre>"},{"location":"setup/hooks/","title":"Extending Uplift with Hooks","text":"<p>Uplift can be extended through the use of hooks. A hook is a specific point during a workflow where Uplift executes adhoc shell commands and scripts. If you need to print the output from any command or script, use the <code>--debug</code> flag.</p> <ul> <li><code>before</code>: a hook that executes before any tasks within the workflow</li> <li><code>after</code>: a hook that executes after completing all workflow tasks</li> <li><code>beforeBump</code>: a hook that executes before bumping any configured files</li> <li><code>afterBump</code>: a hook that executes after bumping all configured files</li> <li><code>beforeChangelog</code>: a hook that executes before generating a changelog</li> <li><code>afterChangelog</code>: a hook that executes after changelog generation</li> <li><code>beforeTag</code>: a hook that executes before tagging the repository</li> <li><code>afterTag</code>: a hook that executes after the repository is tagged</li> </ul> <pre><code># .uplift.yml\nhooks:\nbefore:\n- cargo fetch\n- ENV=VALUE ./my-custom-script.sh\n- bash path//to//my-custom-script.sh # (1)\n</code></pre> <ol> <li>An example of invoking a script using a POSIX-based Windows shell. Pay special attention to the use of <code>//</code> when specifying a path</li> </ol> <p>\u2764\ufe0f to the github.com/mvdan/sh library.</p>"},{"location":"setup/hooks/#injecting-environment-variables","title":"Injecting Environment Variables","text":"<p>Extend hook support by defining environment variables that Uplift will inject into the runtime environment. Either list environment variables individually or import them through dotenv (.env) files. Uplift will merge all environment variables with any pre-existing system ones.</p> <pre><code># .uplift.yml\nenv:\n- VARIABLE=VALUE\n- ANOTHER_VARIABLE=ANOTHER VALUE\n- .env\n- path/to/other.env\n</code></pre> <p>\u2764\ufe0f to the github.com/joho/godotenv library.</p>"},{"location":"setup/print-tags/","title":"Printing Repository Tags","text":"<p>Uplift provides utility functions for printing the current or next calculated semantic version of your repository to <code>stdout</code>. Useful if you want to use Uplift alongside other tools in your CI.</p>"},{"location":"setup/print-tags/#printing-the-next-tag","title":"Printing the Next Tag","text":"<p>Scans all commits from the latest release<sup>1</sup> and prints the next calculated semantic version to <code>stdout</code>. Prints an empty string if no commits exist that triggers the next semantic version.</p> <pre><code>NEXT_TAG=$(uplift tag --next --silent)\n</code></pre>"},{"location":"setup/print-tags/#printing-the-current-tag","title":"Printing the Current Tag","text":"<p>Scans and prints the most recent semantic version from a repository with existing git tags to <code>stdout</code>. Prints an empty string if no tags exist.</p> <pre><code>CURRENT_TAG=$(uplift tag --current)\n</code></pre>"},{"location":"setup/print-tags/#printing-the-tag-transition","title":"Printing the Tag Transition","text":"<p>Scans all commits from the latest release<sup>1</sup> and prints the current and next calculated semantic version to <code>stdout</code>. Both tags are separated by one whitespace ensuring compatibility with many Linux text processing tools, e.g. <code>v0.1.0 v0.2.0</code>. Prints an empty string if no commits exist that triggers the next semantic version.</p> <pre><code>TAG_TRANSITION=$(uplift tag --current --next --silent)\n</code></pre> <ol> <li> <p>If this is a repository without any previous releases, Uplift will scan the entire commit history\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"setup/silent/","title":"Silencing all Output","text":"<p>If you want to stop all logging when running any Uplift command, use the <code>--silent</code> flag.</p> <pre><code>uplift release --silent\n</code></pre>"}]}