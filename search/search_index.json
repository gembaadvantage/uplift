{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 \"Semantic versioning the easy way. Powered by Conventional Commits. Built for use with CI\" Uplift is designed to simplify release management within a project. By harnessing the power of conventional commits , release automation can be introduced into any CI workflow. Uplift works by analysing the latest conventional commit message to identify the next semantic release. If a semantic release is identified, uplift will release the project. A release can comprise of file bumping (updating the version within a file), changelog management and tagging of a repository, all configurable through uplifts commands and/or configuration file. Being built using Go, uplift is incredibly small and easy to install into any CI workflow. Once you are setup, you won't have to do anything again. Uplift will take care of the rest for you!","title":"Home"},{"location":"#introduction","text":"\"Semantic versioning the easy way. Powered by Conventional Commits. Built for use with CI\" Uplift is designed to simplify release management within a project. By harnessing the power of conventional commits , release automation can be introduced into any CI workflow. Uplift works by analysing the latest conventional commit message to identify the next semantic release. If a semantic release is identified, uplift will release the project. A release can comprise of file bumping (updating the version within a file), changelog management and tagging of a repository, all configurable through uplifts commands and/or configuration file. Being built using Go, uplift is incredibly small and easy to install into any CI workflow. Once you are setup, you won't have to do anything again. Uplift will take care of the rest for you!","title":"Introduction"},{"location":"install/","text":"Install \u00b6 There are many different ways to install uplift. You can install the binary using either a supported package manager, manually, or by compiling the source yourself. Installing the binary \u00b6 Homebrew \u00b6 To use Homebrew : brew install gembaadvantage/tap/uplift Scoop \u00b6 To use Scoop : scoop install uplift Apt \u00b6 To install using the apt package manager: echo 'deb [trusted=yes] https://fury.upliftci.dev/apt/ /' | sudo tee /etc/apt/sources.list.d/uplift.list sudo apt update sudo apt install -y uplift You may need to install the ca-certificates package if you encounter trust issues with regards to the gemfury certificate: sudo apt update && sudo apt install -y ca-certificates Yum \u00b6 To install using the yum package manager: echo '[uplift] name=uplift baseurl=https://fury.upliftci.dev/yum/ enabled=1 gpgcheck=0' | sudo tee /etc/yum.repos.d/uplift.repo sudo yum install -y uplift Aur \u00b6 To install from the aur using yay : yay -S uplift-bin Linux Packages \u00b6 Download and manually install one of the .deb , .rpm or .apk packages from the Releases page. sudo apt install uplift_*.deb sudo yum localinstall uplift_*.rpm sudo apk add --no-cache --allow-untrusted uplift_*.apk Bash Script \u00b6 To install the latest version using a bash script: curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash A specific version can be downloaded by using the -v flag. By default the script uses sudo , which can be turned off by using the --no-sudo flag. curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash -s -- -v v2.6.3 --no-sudo Manually \u00b6 Binary downloads of uplift can be found on the Releases page. Unpack the uplift binary and add it to your PATH . Compiling from source \u00b6 Uplift is written using Go 1.18+ and should be installed along with go-task , as it is preferred over using make. Then clone the code from GitHub: git clone https://github.com/gembaadvantage/uplift.git cd uplift Build uplift: task And check that everything works: ./bin/uplift version Fancy Contributing? Since you have the code checked out and locally built, you are only one step away from contributing. Take a peek at the Contributing Guide Verifying Artefacts \u00b6 All verification is carried out using cosign and it must be installed before proceeding. Binaries \u00b6 All binaries can be verified using the checksum file, which has been signed using cosign. Download the checksum files that need to be verified: curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt -O curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt.sig -O curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt.pem -O Verify the signature of the checksum file: cosign verify-blob --cert checksums.txt.pem --signature checksums.txt.sig checksums.txt Download any release artefact and verify its SHA256 signature matches the entry within the checksum file: sha256sum --ignore-missing -c checksums.txt Don't mix versions For checksum verification to work, all artefacts must be downloaded from the same release Docker \u00b6 Docker images can be verified using cosign directly, as the signature will be embedded within the docker manifest. Cosign Verification Cosign verification was introduced to all docker images from version v2.5.0 DockerHub GHCR COSIGN_EXPERIMENTAL = 1 cosign verify gembaadvantage/uplift COSIGN_EXPERIMENTAL = 1 cosign verify ghcr.io/gembaadvantage/uplift Running with Docker \u00b6 You can run uplift directly from a docker image. Depending on how you have cloned the repository, you may need to tweak the following command to work for your setup. DockerHub GHCR docker run --rm -v $PWD :/tmp -w /tmp gembaadvantage/uplift release docker run --rm -v $PWD :/tmp -w /tmp ghcr.io/gembaadvantage/uplift release Issue with SSH Cloned Repositories Outstanding issue with pushing changes back to a cloned SSH repository, see: #148 Oh My Zsh \u00b6 Install the custom uplift plugin for full autocompletion support.","title":"Install"},{"location":"install/#install","text":"There are many different ways to install uplift. You can install the binary using either a supported package manager, manually, or by compiling the source yourself.","title":"Install"},{"location":"install/#installing-the-binary","text":"","title":"Installing the binary"},{"location":"install/#homebrew","text":"To use Homebrew : brew install gembaadvantage/tap/uplift","title":"Homebrew"},{"location":"install/#scoop","text":"To use Scoop : scoop install uplift","title":"Scoop"},{"location":"install/#apt","text":"To install using the apt package manager: echo 'deb [trusted=yes] https://fury.upliftci.dev/apt/ /' | sudo tee /etc/apt/sources.list.d/uplift.list sudo apt update sudo apt install -y uplift You may need to install the ca-certificates package if you encounter trust issues with regards to the gemfury certificate: sudo apt update && sudo apt install -y ca-certificates","title":"Apt"},{"location":"install/#yum","text":"To install using the yum package manager: echo '[uplift] name=uplift baseurl=https://fury.upliftci.dev/yum/ enabled=1 gpgcheck=0' | sudo tee /etc/yum.repos.d/uplift.repo sudo yum install -y uplift","title":"Yum"},{"location":"install/#aur","text":"To install from the aur using yay : yay -S uplift-bin","title":"Aur"},{"location":"install/#linux-packages","text":"Download and manually install one of the .deb , .rpm or .apk packages from the Releases page. sudo apt install uplift_*.deb sudo yum localinstall uplift_*.rpm sudo apk add --no-cache --allow-untrusted uplift_*.apk","title":"Linux Packages"},{"location":"install/#bash-script","text":"To install the latest version using a bash script: curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash A specific version can be downloaded by using the -v flag. By default the script uses sudo , which can be turned off by using the --no-sudo flag. curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash -s -- -v v2.6.3 --no-sudo","title":"Bash Script"},{"location":"install/#manually","text":"Binary downloads of uplift can be found on the Releases page. Unpack the uplift binary and add it to your PATH .","title":"Manually"},{"location":"install/#compiling-from-source","text":"Uplift is written using Go 1.18+ and should be installed along with go-task , as it is preferred over using make. Then clone the code from GitHub: git clone https://github.com/gembaadvantage/uplift.git cd uplift Build uplift: task And check that everything works: ./bin/uplift version Fancy Contributing? Since you have the code checked out and locally built, you are only one step away from contributing. Take a peek at the Contributing Guide","title":"Compiling from source"},{"location":"install/#verifying-artefacts","text":"All verification is carried out using cosign and it must be installed before proceeding.","title":"Verifying Artefacts"},{"location":"install/#binaries","text":"All binaries can be verified using the checksum file, which has been signed using cosign. Download the checksum files that need to be verified: curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt -O curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt.sig -O curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt.pem -O Verify the signature of the checksum file: cosign verify-blob --cert checksums.txt.pem --signature checksums.txt.sig checksums.txt Download any release artefact and verify its SHA256 signature matches the entry within the checksum file: sha256sum --ignore-missing -c checksums.txt Don't mix versions For checksum verification to work, all artefacts must be downloaded from the same release","title":"Binaries"},{"location":"install/#docker","text":"Docker images can be verified using cosign directly, as the signature will be embedded within the docker manifest. Cosign Verification Cosign verification was introduced to all docker images from version v2.5.0 DockerHub GHCR COSIGN_EXPERIMENTAL = 1 cosign verify gembaadvantage/uplift COSIGN_EXPERIMENTAL = 1 cosign verify ghcr.io/gembaadvantage/uplift","title":"Docker"},{"location":"install/#running-with-docker","text":"You can run uplift directly from a docker image. Depending on how you have cloned the repository, you may need to tweak the following command to work for your setup. DockerHub GHCR docker run --rm -v $PWD :/tmp -w /tmp gembaadvantage/uplift release docker run --rm -v $PWD :/tmp -w /tmp ghcr.io/gembaadvantage/uplift release Issue with SSH Cloned Repositories Outstanding issue with pushing changes back to a cloned SSH repository, see: #148","title":"Running with Docker"},{"location":"install/#oh-my-zsh","text":"Install the custom uplift plugin for full autocompletion support.","title":"Oh My Zsh"},{"location":"ci/about/","text":"Continuous Integration \u00b6 Uplift was designed for use within CI. With the goal of simplifying release management. To speed up the adoption of uplift within your CI pipelines, some examples have been provided based on the top CI providers. Hopefully they serve as a good starting point for your CI workflow. Have we missed anything? Get in touch, or raise a PR, if we have either missed a CI provider or one of the provided examples could be improved. Take a peek at the Contributing Guide","title":"About"},{"location":"ci/about/#continuous-integration","text":"Uplift was designed for use within CI. With the goal of simplifying release management. To speed up the adoption of uplift within your CI pipelines, some examples have been provided based on the top CI providers. Hopefully they serve as a good starting point for your CI workflow. Have we missed anything? Get in touch, or raise a PR, if we have either missed a CI provider or one of the provided examples could be improved. Take a peek at the Contributing Guide","title":"Continuous Integration"},{"location":"ci/awscodebuild/","text":"AWS CodeBuild \u00b6 AWS CodeBuild can be used as a standalone service when running uplift. This guide assumes CodeBuild was configured manually through the AWS Console and only focuses on the gotchas 1 . CodeBuild will always receive a git clone with a detached HEAD. By default, uplift will error in this scenario. When performing a release, this will need to be resolved through a git checkout . The CODEBUILD_SOURCE_VERSION variable contains the necessary git reference. IAM \u00b6 Additional permissions are needed to pull and push code within AWS CodeBuild. These vary based on the SCM used. Principle of Least Privilege For illustration purposes, a resource type of \"*\" is used. This should always be narrowed to the specific resource when possible. CodeCommit \u00b6 The codecommit:GitPush IAM permission needs to be added. By default, the associated service role will already have the codecommit:GitPull permission. 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"CodeCommitUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codecommit:GitPush\" ], \"Resource\" : \"*\" } ] } GitHub \u00b6 Permissions are granted through the AWS Connector for GitHub OAuth application from the AWS Console. Buildspec \u00b6 The buildspec can change depending on the base image used by the CodeBuild project. Amazon Images \u00b6 Tested against the Amazon Linux 2, Ubuntu and Windows variants. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # buildspec.yml version : 0.2 env : git-credential-helper : yes # (1) phases : install : commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash pre_build : commands : - git checkout ${CODEBUILD_SOURCE_VERSION##\"refs/heads/\"} # (2) build : commands : - uplift release Without this uplift will lack any credentials when attempting to push code back to the source SCM. This can be simplified to git checkout $CODEBUILD_SOURCE_VERSION when cloning from GitHub directly Official Uplift Image \u00b6 Tested against the public gembaadvantage/uplift image. Dealing with DockerHub Rate Limits There are known issues with accessing public DockerHub repositories from AWS services, documented here . 1 2 3 4 5 6 7 8 9 10 11 12 # buildspec.yml version : 0.2 env : git-credential-helper : yes phases : pre_build : commands : - git checkout ${CODEBUILD_SOURCE_VERSION##\"refs/heads/\"} build : commands : - uplift release Clone Depth \u00b6 While configuring a CodeBuild project, the clone depth can be specified. For simplicity, a full clone should be used. If a shallow clone is preferred, you may need to fetch all tags by using the --fetch-all flag. A preferred approach for generating an AWS CodePipeline would be to either write a CloudFormation template manually or use the AWS CDK tooling. This is known as Infrastructure as Code (IaC), and wasn't included in the documentation to avoid unnecessary complexity. \u21a9","title":"AWS CodeBuild"},{"location":"ci/awscodebuild/#aws-codebuild","text":"AWS CodeBuild can be used as a standalone service when running uplift. This guide assumes CodeBuild was configured manually through the AWS Console and only focuses on the gotchas 1 . CodeBuild will always receive a git clone with a detached HEAD. By default, uplift will error in this scenario. When performing a release, this will need to be resolved through a git checkout . The CODEBUILD_SOURCE_VERSION variable contains the necessary git reference.","title":"AWS CodeBuild"},{"location":"ci/awscodebuild/#iam","text":"Additional permissions are needed to pull and push code within AWS CodeBuild. These vary based on the SCM used. Principle of Least Privilege For illustration purposes, a resource type of \"*\" is used. This should always be narrowed to the specific resource when possible.","title":"IAM"},{"location":"ci/awscodebuild/#codecommit","text":"The codecommit:GitPush IAM permission needs to be added. By default, the associated service role will already have the codecommit:GitPull permission. 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"CodeCommitUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codecommit:GitPush\" ], \"Resource\" : \"*\" } ] }","title":"CodeCommit"},{"location":"ci/awscodebuild/#github","text":"Permissions are granted through the AWS Connector for GitHub OAuth application from the AWS Console.","title":"GitHub"},{"location":"ci/awscodebuild/#buildspec","text":"The buildspec can change depending on the base image used by the CodeBuild project.","title":"Buildspec"},{"location":"ci/awscodebuild/#amazon-images","text":"Tested against the Amazon Linux 2, Ubuntu and Windows variants. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # buildspec.yml version : 0.2 env : git-credential-helper : yes # (1) phases : install : commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash pre_build : commands : - git checkout ${CODEBUILD_SOURCE_VERSION##\"refs/heads/\"} # (2) build : commands : - uplift release Without this uplift will lack any credentials when attempting to push code back to the source SCM. This can be simplified to git checkout $CODEBUILD_SOURCE_VERSION when cloning from GitHub directly","title":"Amazon Images"},{"location":"ci/awscodebuild/#official-uplift-image","text":"Tested against the public gembaadvantage/uplift image. Dealing with DockerHub Rate Limits There are known issues with accessing public DockerHub repositories from AWS services, documented here . 1 2 3 4 5 6 7 8 9 10 11 12 # buildspec.yml version : 0.2 env : git-credential-helper : yes phases : pre_build : commands : - git checkout ${CODEBUILD_SOURCE_VERSION##\"refs/heads/\"} build : commands : - uplift release","title":"Official Uplift Image"},{"location":"ci/awscodebuild/#clone-depth","text":"While configuring a CodeBuild project, the clone depth can be specified. For simplicity, a full clone should be used. If a shallow clone is preferred, you may need to fetch all tags by using the --fetch-all flag. A preferred approach for generating an AWS CodePipeline would be to either write a CloudFormation template manually or use the AWS CDK tooling. This is known as Infrastructure as Code (IaC), and wasn't included in the documentation to avoid unnecessary complexity. \u21a9","title":"Clone Depth"},{"location":"ci/awscodepipeline/","text":"AWS CodePipeline \u00b6 AWS provides two developer services for building code, AWS CodePipeline and AWS CodeBuild . The former being an orchestration tool, while the later executes each stage using a buildspec file. This guide assumes both were configured manually through the AWS Console and only focuses on the gotchas 1 . CodePipeline \u00b6 By default, CodePipeline clones a repository to S3 without the .git metadata folder. A full clone 2 is needed for uplift to run. CodeBuild \u00b6 CodeBuild will always receive a git clone with a detached HEAD. By default, uplift will error in this scenario. If performing a release, this will need to be resolved through a git checkout . However, the branch name is not exposed to CodeBuild by default. CodePipeline provides a variable #{SourceVariables.BranchName} that can be mapped to CodeBuild as an environment variable: IAM \u00b6 Additional permissions are needed to pull and push code within AWS CodeBuild. These vary based on the SCM used. Principle of Least Privilege For illustration purposes, a resource type of \"*\" is used. This should always be narrowed to the specific resource when possible. CodeCommit \u00b6 Both the codecommit:GitPull and codecommit:GitPush IAM permissions are needed and should be added to the CodeBuild service role. 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"CodeCommitUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codecommit:GitPull\" , \"codecommit:GitPush\" ], \"Resource\" : \"*\" } ] } GitHub \u00b6 The codestar-connections:UseConnection IAM permission is needed when interacting with GitHub through an AWS CodeStar connection . 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"GitHubUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codestar-connections:UseConnection\" ], \"Resource\" : \"*\" } ] } Buildspec \u00b6 The buildspec will change depending on the CodeBuild project base image. Default Amazon Images \u00b6 Tested against the Amazon Linux 2, Ubuntu and Windows variants. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # buildspec.yml version : 0.2 env : git-credential-helper : yes # (1) phases : install : commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash pre_build : commands : - git checkout $BRANCH_NAME # (2) build : commands : - uplift release Without this uplift will lack any credentials when attempting to push code back to the source SCM. The BRANCH_NAME environment variable can be referenced directly within the buildspec, once mapped. Official Uplift Image \u00b6 Tested against the public gembaadvantage/uplift image. Dealing with DockerHub Rate Limits There are known issues with accessing public DockerHub repositories from AWS services, documented here . 1 2 3 4 5 6 7 8 9 10 11 12 # buildspec.yml version : 0.2 env : git-credential-helper : yes phases : pre_build : commands : - git checkout $BRANCH_NAME build : commands : - uplift release A preferred approach for generating an AWS CodePipeline would be to either write a CloudFormation template manually or use the AWS CDK tooling. This is known as Infrastructure as Code (IaC), and wasn't included in the documentation to avoid unnecessary complexity. \u21a9 This strategy works for all supported SCM providers. \u21a9","title":"AWS CodePipeline"},{"location":"ci/awscodepipeline/#aws-codepipeline","text":"AWS provides two developer services for building code, AWS CodePipeline and AWS CodeBuild . The former being an orchestration tool, while the later executes each stage using a buildspec file. This guide assumes both were configured manually through the AWS Console and only focuses on the gotchas 1 .","title":"AWS CodePipeline"},{"location":"ci/awscodepipeline/#codepipeline","text":"By default, CodePipeline clones a repository to S3 without the .git metadata folder. A full clone 2 is needed for uplift to run.","title":"CodePipeline"},{"location":"ci/awscodepipeline/#codebuild","text":"CodeBuild will always receive a git clone with a detached HEAD. By default, uplift will error in this scenario. If performing a release, this will need to be resolved through a git checkout . However, the branch name is not exposed to CodeBuild by default. CodePipeline provides a variable #{SourceVariables.BranchName} that can be mapped to CodeBuild as an environment variable:","title":"CodeBuild"},{"location":"ci/awscodepipeline/#iam","text":"Additional permissions are needed to pull and push code within AWS CodeBuild. These vary based on the SCM used. Principle of Least Privilege For illustration purposes, a resource type of \"*\" is used. This should always be narrowed to the specific resource when possible.","title":"IAM"},{"location":"ci/awscodepipeline/#codecommit","text":"Both the codecommit:GitPull and codecommit:GitPush IAM permissions are needed and should be added to the CodeBuild service role. 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"CodeCommitUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codecommit:GitPull\" , \"codecommit:GitPush\" ], \"Resource\" : \"*\" } ] }","title":"CodeCommit"},{"location":"ci/awscodepipeline/#github","text":"The codestar-connections:UseConnection IAM permission is needed when interacting with GitHub through an AWS CodeStar connection . 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"GitHubUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codestar-connections:UseConnection\" ], \"Resource\" : \"*\" } ] }","title":"GitHub"},{"location":"ci/awscodepipeline/#buildspec","text":"The buildspec will change depending on the CodeBuild project base image.","title":"Buildspec"},{"location":"ci/awscodepipeline/#default-amazon-images","text":"Tested against the Amazon Linux 2, Ubuntu and Windows variants. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # buildspec.yml version : 0.2 env : git-credential-helper : yes # (1) phases : install : commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash pre_build : commands : - git checkout $BRANCH_NAME # (2) build : commands : - uplift release Without this uplift will lack any credentials when attempting to push code back to the source SCM. The BRANCH_NAME environment variable can be referenced directly within the buildspec, once mapped.","title":"Default Amazon Images"},{"location":"ci/awscodepipeline/#official-uplift-image","text":"Tested against the public gembaadvantage/uplift image. Dealing with DockerHub Rate Limits There are known issues with accessing public DockerHub repositories from AWS services, documented here . 1 2 3 4 5 6 7 8 9 10 11 12 # buildspec.yml version : 0.2 env : git-credential-helper : yes phases : pre_build : commands : - git checkout $BRANCH_NAME build : commands : - uplift release A preferred approach for generating an AWS CodePipeline would be to either write a CloudFormation template manually or use the AWS CDK tooling. This is known as Infrastructure as Code (IaC), and wasn't included in the documentation to avoid unnecessary complexity. \u21a9 This strategy works for all supported SCM providers. \u21a9","title":"Official Uplift Image"},{"location":"ci/circleci/","text":"CircleCI \u00b6 An example YAML file 1 for configuring uplift to run on CircleCI . As uplift is designed to push changes back to your GitHub repository you will need to ensure CircleCI is granted write access to your repository. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # .circleci/config.yml version : 2.1 workflows : main : jobs : - release : filters : branches : # Only trigger on the main branch only : main jobs : release : docker : # Can use whatever base image you like - image : cimg/go:1.18 steps : # Configure an SSH key that provides write access to your GitHub repository - add_ssh_keys : fingerprints : - \"3b:c7:44:c9:34:ab:a4:fd:6c:33:4e:a7:7a:97:79:55\" # (1) - checkout # Additional actions specified here - run : curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash - run : uplift release By default CircleCI will only have read-only access to your repository. For uplift to work, write access is required. This can be achieved by accessing a repository as a machine-user and then loading its SSH key into the pipeline by its fingerprint There are many different ways of installing uplift within a pipeline. Sudo access is needed when installing the binary into a protected path such as /usr/local/bin \u21a9","title":"CircleCI"},{"location":"ci/circleci/#circleci","text":"An example YAML file 1 for configuring uplift to run on CircleCI . As uplift is designed to push changes back to your GitHub repository you will need to ensure CircleCI is granted write access to your repository. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # .circleci/config.yml version : 2.1 workflows : main : jobs : - release : filters : branches : # Only trigger on the main branch only : main jobs : release : docker : # Can use whatever base image you like - image : cimg/go:1.18 steps : # Configure an SSH key that provides write access to your GitHub repository - add_ssh_keys : fingerprints : - \"3b:c7:44:c9:34:ab:a4:fd:6c:33:4e:a7:7a:97:79:55\" # (1) - checkout # Additional actions specified here - run : curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash - run : uplift release By default CircleCI will only have read-only access to your repository. For uplift to work, write access is required. This can be achieved by accessing a repository as a machine-user and then loading its SSH key into the pipeline by its fingerprint There are many different ways of installing uplift within a pipeline. Sudo access is needed when installing the binary into a protected path such as /usr/local/bin \u21a9","title":"CircleCI"},{"location":"ci/cirrusci/","text":"Cirrus CI \u00b6 An example YAML file for configuring uplift to run on Cirrus CI . Access to GitHub is managed through their dedicated GitHub Application . As uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the public_repo permission and added to Cirrus CI as an encrypted variable . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # .cirrus.yml task : name : Release # Only run on the main branch only_if : $BRANCH == \"main\" && $CIRRUS_TAG == \"\" container : image : gembaadvantage/uplift:latest before_script : - CLONE_URL=${CIRRUS_REPO_CLONE_URL#\"https://\"} - git remote set-url origin \"https://${GITHUB_TOKEN}@${CLONE_URL}\" release_script : - uplift release --fetch-all # (1) environment : GITHUB_TOKEN : ENCRYPTED[!ID!] # (2) As Cirrus CI uses go-git for cloning repositories from GitHub, by default it doesn't fetch tags. Using the --fetch-all flag with uplift ensures all tags are pulled before attempting a release !ID! should be replaced with the internal ID generated by Cirrus CI. GITHUB_TOKEN can be replaced with any chosen variable name, and must be reflected in the remote URL. environment and env are interchangeable. Uplift publishes docker images that support both amd64 and arm64 architectures, Cirrus CI can be configured to use arm64 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # .cirrus.yml task : name : Release # Only run on the main branch only_if : $BRANCH == \"main\" && $CIRRUS_TAG == \"\" arm_container : image : gembaadvantage/uplift:latest # (1) before_script : - CLONE_URL=${CIRRUS_REPO_CLONE_URL#\"https://\"} - git remote set-url origin \"https://${GITHUB_TOKEN}@${CLONE_URL}\" release_script : - uplift release --fetch-all environment : GITHUB_TOKEN : ENCRYPTED[!ID!] Cirrus CI will seamlessly download the arm64 image from either DockerHub or GHCR though the use of the --platform flag.","title":"Cirrus CI"},{"location":"ci/cirrusci/#cirrus-ci","text":"An example YAML file for configuring uplift to run on Cirrus CI . Access to GitHub is managed through their dedicated GitHub Application . As uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the public_repo permission and added to Cirrus CI as an encrypted variable . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # .cirrus.yml task : name : Release # Only run on the main branch only_if : $BRANCH == \"main\" && $CIRRUS_TAG == \"\" container : image : gembaadvantage/uplift:latest before_script : - CLONE_URL=${CIRRUS_REPO_CLONE_URL#\"https://\"} - git remote set-url origin \"https://${GITHUB_TOKEN}@${CLONE_URL}\" release_script : - uplift release --fetch-all # (1) environment : GITHUB_TOKEN : ENCRYPTED[!ID!] # (2) As Cirrus CI uses go-git for cloning repositories from GitHub, by default it doesn't fetch tags. Using the --fetch-all flag with uplift ensures all tags are pulled before attempting a release !ID! should be replaced with the internal ID generated by Cirrus CI. GITHUB_TOKEN can be replaced with any chosen variable name, and must be reflected in the remote URL. environment and env are interchangeable. Uplift publishes docker images that support both amd64 and arm64 architectures, Cirrus CI can be configured to use arm64 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # .cirrus.yml task : name : Release # Only run on the main branch only_if : $BRANCH == \"main\" && $CIRRUS_TAG == \"\" arm_container : image : gembaadvantage/uplift:latest # (1) before_script : - CLONE_URL=${CIRRUS_REPO_CLONE_URL#\"https://\"} - git remote set-url origin \"https://${GITHUB_TOKEN}@${CLONE_URL}\" release_script : - uplift release --fetch-all environment : GITHUB_TOKEN : ENCRYPTED[!ID!] Cirrus CI will seamlessly download the arm64 image from either DockerHub or GHCR though the use of the --platform flag.","title":"Cirrus CI"},{"location":"ci/codefresh/","text":"Codefresh \u00b6 An example YAML file for configuring uplift to run on Codefresh . To ensure uplift can push changes back to your repository, you will need to store your Personal Access Token as a shared configuration and expose it to your pipeline as an environment variable. Which in this example is GH_UPLIFT . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # codefresh.yml version : \"1.0\" stages : - prepare - release steps : main_clone : # (1) title : \"Checkout\" type : git-clone repo : \"${{CF_REPO_OWNER}}/${{CF_REPO_NAME}}\" revision : \"${{CF_BRANCH}}\" # (2) stage : prepare uplift : title : \"Release\" stage : release image : \"gembaadvantage/uplift\" commands : - REMOTE_URL=$(git config --get remote.origin.url) - CLONE_URL=${REMOTE_URL#\"https://\"} - git remote set-url origin \"https://${GH_UPLIFT}@${CLONE_URL}\" - uplift release main_clone is a reserved step within Codefresh and is used to simplify the checkout process. A custom checkout can be performed, but you will need to managed the working directory across all other steps. By ensuring the clone is of a specific branch, it prevents the checkout of a detached HEAD.","title":"Codefresh"},{"location":"ci/codefresh/#codefresh","text":"An example YAML file for configuring uplift to run on Codefresh . To ensure uplift can push changes back to your repository, you will need to store your Personal Access Token as a shared configuration and expose it to your pipeline as an environment variable. Which in this example is GH_UPLIFT . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # codefresh.yml version : \"1.0\" stages : - prepare - release steps : main_clone : # (1) title : \"Checkout\" type : git-clone repo : \"${{CF_REPO_OWNER}}/${{CF_REPO_NAME}}\" revision : \"${{CF_BRANCH}}\" # (2) stage : prepare uplift : title : \"Release\" stage : release image : \"gembaadvantage/uplift\" commands : - REMOTE_URL=$(git config --get remote.origin.url) - CLONE_URL=${REMOTE_URL#\"https://\"} - git remote set-url origin \"https://${GH_UPLIFT}@${CLONE_URL}\" - uplift release main_clone is a reserved step within Codefresh and is used to simplify the checkout process. A custom checkout can be performed, but you will need to managed the working directory across all other steps. By ensuring the clone is of a specific branch, it prevents the checkout of a detached HEAD.","title":"Codefresh"},{"location":"ci/drone/","text":"Drone \u00b6 An example YAML file for configuring uplift to run on Drone 1 . Instructions for deploying a self-hosted instance of drone can be found here . As uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the public_repo permission and added to Drone as an encrypted secret . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # .drone.yml kind : pipeline type : docker name : default steps : - name : set-remote image : docker:git environment : GITHUB_PAT : from_secret : github_pat commands : - CLONE_URL=${DRONE_GIT_HTTP_URL##https://} - git remote set-url origin https://$GITHUB_PAT@$CLONE_URL when : branch : - main event : - push - name : release image : gembaadvantage/uplift commands : - uplift release --fetch-all # (1) when : branch : - main event : - push --- kind : secret name : github_pat data : VLO71Ad3QSALQjELGKg5U7r92823a9e4vmu7xUw3LJ9xKwZu8X... Drone does not retrieve any tags by default. Uplift can retrieve all of the latest tags by providing the --fetch-all flag. Drone still has a self-hosted offering, but its SaaS product is now integrated with Harness CI . \u21a9","title":"Drone"},{"location":"ci/drone/#drone","text":"An example YAML file for configuring uplift to run on Drone 1 . Instructions for deploying a self-hosted instance of drone can be found here . As uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the public_repo permission and added to Drone as an encrypted secret . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # .drone.yml kind : pipeline type : docker name : default steps : - name : set-remote image : docker:git environment : GITHUB_PAT : from_secret : github_pat commands : - CLONE_URL=${DRONE_GIT_HTTP_URL##https://} - git remote set-url origin https://$GITHUB_PAT@$CLONE_URL when : branch : - main event : - push - name : release image : gembaadvantage/uplift commands : - uplift release --fetch-all # (1) when : branch : - main event : - push --- kind : secret name : github_pat data : VLO71Ad3QSALQjELGKg5U7r92823a9e4vmu7xUw3LJ9xKwZu8X... Drone does not retrieve any tags by default. Uplift can retrieve all of the latest tags by providing the --fetch-all flag. Drone still has a self-hosted offering, but its SaaS product is now integrated with Harness CI . \u21a9","title":"Drone"},{"location":"ci/github/","text":"GitHub Action \u00b6 The official GitHub Action can be used to configure uplift within your workflow. As uplift is designed to push changes back to your repository, you will need to provide it with an access token 1 . This is by design . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # .github/workflows/ci.yml name : ci on : push : branches : - main pull_request : jobs : ci : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 with : fetch-depth : 0 # (1) # Additional steps specified here - name : Release if : github.ref == 'refs/heads/main' uses : gembaadvantage/uplift-action@v2.0.1 with : args : release env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} # (2) Setting a fetch-depth of 0 will ensure all tags are retrieved which is required by uplift to determine the next semantic version When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN will not create a new workflow run. Triggering another Workflow \u00b6 To ensure uplift triggers another workflow run when tagging the repository, a personal access token should be created and stored as a secret . This will then replace the default GITHUB_TOKEN as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # .github/workflows/ci.yml name : ci on : push : branches : - main pull_request : jobs : ci : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 with : fetch-depth : 0 # Additional steps specified here - name : Release if : github.ref == 'refs/heads/main' uses : gembaadvantage/uplift-action@v2.0.1 with : args : release env : GITHUB_TOKEN : ${{ secrets.GH_UPLIFT }} It is best security practice to create an access token with the shortest possible expiration date. \u21a9","title":"GitHub Action"},{"location":"ci/github/#github-action","text":"The official GitHub Action can be used to configure uplift within your workflow. As uplift is designed to push changes back to your repository, you will need to provide it with an access token 1 . This is by design . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # .github/workflows/ci.yml name : ci on : push : branches : - main pull_request : jobs : ci : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 with : fetch-depth : 0 # (1) # Additional steps specified here - name : Release if : github.ref == 'refs/heads/main' uses : gembaadvantage/uplift-action@v2.0.1 with : args : release env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} # (2) Setting a fetch-depth of 0 will ensure all tags are retrieved which is required by uplift to determine the next semantic version When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN will not create a new workflow run.","title":"GitHub Action"},{"location":"ci/github/#triggering-another-workflow","text":"To ensure uplift triggers another workflow run when tagging the repository, a personal access token should be created and stored as a secret . This will then replace the default GITHUB_TOKEN as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # .github/workflows/ci.yml name : ci on : push : branches : - main pull_request : jobs : ci : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 with : fetch-depth : 0 # Additional steps specified here - name : Release if : github.ref == 'refs/heads/main' uses : gembaadvantage/uplift-action@v2.0.1 with : args : release env : GITHUB_TOKEN : ${{ secrets.GH_UPLIFT }} It is best security practice to create an access token with the shortest possible expiration date. \u21a9","title":"Triggering another Workflow"},{"location":"ci/gitlab/","text":"GitLab \u00b6 An example YAML file for configuring uplift to run on GitLab . To ensure uplift can push changes back to your repository, you will need to provide it with either a project or group access token 1 with the write_repository permission. # .gitlab-ci.yml stages : - release release : stage : release image : name : gembaadvantage/uplift entrypoint : [ \"\" ] before_script : - PROJECT_URL=${CI_PROJECT_URL#\"https://\"} - git remote set-url origin \"https://oauth2:${GL_UPLIFT}@${PROJECT_URL}.git\" variables : # Disable shallow cloning of repository GIT_DEPTH : 0 script : # GitLab by default checks out a detached HEAD - git checkout $CI_COMMIT_REF_NAME - uplift release # Only run on the default branch of the repository rules : - if : '$CI_PIPELINE_SOURCE == \"merge_request_event\"' when : never - if : \"$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\" when : on_success To expose your access token within your pipeline you should add a CI/CD variable . In the above example, the access token is exposed through the GL_UPLIFT variable. It is best security practice to create an access token with the shortest possible expiration date. \u21a9","title":"GitLab"},{"location":"ci/gitlab/#gitlab","text":"An example YAML file for configuring uplift to run on GitLab . To ensure uplift can push changes back to your repository, you will need to provide it with either a project or group access token 1 with the write_repository permission. # .gitlab-ci.yml stages : - release release : stage : release image : name : gembaadvantage/uplift entrypoint : [ \"\" ] before_script : - PROJECT_URL=${CI_PROJECT_URL#\"https://\"} - git remote set-url origin \"https://oauth2:${GL_UPLIFT}@${PROJECT_URL}.git\" variables : # Disable shallow cloning of repository GIT_DEPTH : 0 script : # GitLab by default checks out a detached HEAD - git checkout $CI_COMMIT_REF_NAME - uplift release # Only run on the default branch of the repository rules : - if : '$CI_PIPELINE_SOURCE == \"merge_request_event\"' when : never - if : \"$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\" when : on_success To expose your access token within your pipeline you should add a CI/CD variable . In the above example, the access token is exposed through the GL_UPLIFT variable. It is best security practice to create an access token with the shortest possible expiration date. \u21a9","title":"GitLab"},{"location":"ci/semaphore/","text":"Semaphore \u00b6 Example YAML files for configuring uplift to run on Semaphore 2.0 . All Semaphore pipelines start with the default file .semaphore/semaphore.yml within your repository. To ensure uplift is only executed on the main branch, a separate pipeline YAML file is used, triggered by semaphore promotions . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # .semaphore/semaphore.yml version : v1.0 name : CI Pipeline agent : machine : type : e1-standard-2 os_image : ubuntu2004 blocks : - name : \"CI\" task : jobs : - name : \"Checkout\" commands : - checkout # Additional jobs specified here # Promotions are used to optionally trigger uplift on any push to the main branch promotions : - name : Uplift pipeline_file : uplift.yml auto_promote_on : - result : passed branch : - main A dedicated pipeline installs 1 uplift and triggers a release: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # .semaphore/uplift.yml version : \"v1.0\" name : Uplift agent : machine : type : e1-standard-2 os_image : ubuntu2004 blocks : - name : \"Release\" task : prologue : commands : - checkout jobs : - name : uplift commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash - uplift release # (1) By default Semaphore installs a GitHub application that has write access to a list of preselected repositories. This ensures no additional configuration is needed to grant uplift permissions for pushing changes back to GitHub There are many different ways of installing uplift within a pipeline. Sudo access is needed when installing the binary into a protected path such as /usr/local/bin \u21a9","title":"Semaphore"},{"location":"ci/semaphore/#semaphore","text":"Example YAML files for configuring uplift to run on Semaphore 2.0 . All Semaphore pipelines start with the default file .semaphore/semaphore.yml within your repository. To ensure uplift is only executed on the main branch, a separate pipeline YAML file is used, triggered by semaphore promotions . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # .semaphore/semaphore.yml version : v1.0 name : CI Pipeline agent : machine : type : e1-standard-2 os_image : ubuntu2004 blocks : - name : \"CI\" task : jobs : - name : \"Checkout\" commands : - checkout # Additional jobs specified here # Promotions are used to optionally trigger uplift on any push to the main branch promotions : - name : Uplift pipeline_file : uplift.yml auto_promote_on : - result : passed branch : - main A dedicated pipeline installs 1 uplift and triggers a release: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # .semaphore/uplift.yml version : \"v1.0\" name : Uplift agent : machine : type : e1-standard-2 os_image : ubuntu2004 blocks : - name : \"Release\" task : prologue : commands : - checkout jobs : - name : uplift commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash - uplift release # (1) By default Semaphore installs a GitHub application that has write access to a list of preselected repositories. This ensures no additional configuration is needed to grant uplift permissions for pushing changes back to GitHub There are many different ways of installing uplift within a pipeline. Sudo access is needed when installing the binary into a protected path such as /usr/local/bin \u21a9","title":"Semaphore"},{"location":"ci/travisci/","text":"Travis CI \u00b6 An example YAML file 1 for configuring uplift to run on Travis CI . Access to GitHub is managed through their dedicated GitHub Application . As uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the public_repo permission and added to Travis CI as an encrypted variable . # .travis.yml # Setup the pipeline based on your chosen language language : go git : depth : false before_install : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash script : - git remote set-url origin https://${GH_UPLIFT}@github.com/${TRAVIS_REPO_SLUG}.git - git checkout $TRAVIS_BRANCH deploy : - provider : script skip_cleanup : true script : uplift release on : branch : main condition : $TRAVIS_OS_NAME = linux # (1) env : global : secure : 0l3pSB3Du+YQuV4Gf0R2PoPlrGnmuQhpEbab4KmgUJu6P4S.... # (2) If you have configured Travis CI to use a build matrix , a condition like this should be used to ensure uplift is only run once. You will need to download travis in order to encrypt variables. Once downloaded, you must first login travis --login --pro --github-token=<TRAVIS_TOKEN> and then generate an encrypted variable with a command similar to echo GH_UPLIFT=<PERSONAL_ACCESS_TOKEN> | travis encrypt --add --pro There are many different ways of installing uplift within a pipeline. Sudo access is needed when installing the binary into a protected path such as /usr/local/bin \u21a9","title":"Travis CI"},{"location":"ci/travisci/#travis-ci","text":"An example YAML file 1 for configuring uplift to run on Travis CI . Access to GitHub is managed through their dedicated GitHub Application . As uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the public_repo permission and added to Travis CI as an encrypted variable . # .travis.yml # Setup the pipeline based on your chosen language language : go git : depth : false before_install : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash script : - git remote set-url origin https://${GH_UPLIFT}@github.com/${TRAVIS_REPO_SLUG}.git - git checkout $TRAVIS_BRANCH deploy : - provider : script skip_cleanup : true script : uplift release on : branch : main condition : $TRAVIS_OS_NAME = linux # (1) env : global : secure : 0l3pSB3Du+YQuV4Gf0R2PoPlrGnmuQhpEbab4KmgUJu6P4S.... # (2) If you have configured Travis CI to use a build matrix , a condition like this should be used to ensure uplift is only run once. You will need to download travis in order to encrypt variables. Once downloaded, you must first login travis --login --pro --github-token=<TRAVIS_TOKEN> and then generate an encrypted variable with a command similar to echo GH_UPLIFT=<PERSONAL_ACCESS_TOKEN> | travis encrypt --add --pro There are many different ways of installing uplift within a pipeline. Sudo access is needed when installing the binary into a protected path such as /usr/local/bin \u21a9","title":"Travis CI"},{"location":"cmd/bump/","text":"uplift bump \u00b6 Bumps the semantic version within files in your git repository. The version bump is based on the conventional commit message from the last commit. Uplift can bump the version in any file using regex pattern matching uplift bump [ FLAGS ] Flags \u00b6 --prerelease \u00b6 Append a prerelease suffix to the next calculated semantic version and use it as a prerelease tag. Supporting the Semver 2.0.0 specification, additional labels can be provided for both the prerelease and metadata parts: 1.0.0 -beta.1 1.1.0 -beta.1+20220312 uplift bump --prerelease beta.1","title":"uplift bump"},{"location":"cmd/bump/#uplift-bump","text":"Bumps the semantic version within files in your git repository. The version bump is based on the conventional commit message from the last commit. Uplift can bump the version in any file using regex pattern matching uplift bump [ FLAGS ]","title":"uplift bump"},{"location":"cmd/bump/#flags","text":"","title":"Flags"},{"location":"cmd/bump/#-prerelease","text":"Append a prerelease suffix to the next calculated semantic version and use it as a prerelease tag. Supporting the Semver 2.0.0 specification, additional labels can be provided for both the prerelease and metadata parts: 1.0.0 -beta.1 1.1.0 -beta.1+20220312 uplift bump --prerelease beta.1","title":"--prerelease"},{"location":"cmd/changelog/","text":"uplift changelog \u00b6 Create or update an existing changelog with an entry for the latest semantic release. For a first release, all commits between the latest tag and trunk will be written to the changelog. Subsequent entries will contain only commits between release tags. uplift changelog [ FLAGS ] Flags \u00b6 --all \u00b6 Generates a changelog from the entire history of the git repository. Provides a great way to migrate an existing changelog process to uplift. uplift changelog --all --diff-only \u00b6 Writes the calculated changelog diff to stdout without modifying the current repository. Useful for combining uplift with any other tooling. $ uplift changelog --diff-only \u2022 changelog \u2022 determine changes for release tag = 1 .0.0 \u2022 changeset identified commits = 3 date = 2022 -03-25 tag = 1 .0.0 ## [1.0.0] - 2022-03-25 - ` e988091 ` feat: a brand new feature - ` 11d039b ` ci: speed up existing workflow - ` fad2c38 ` docs: update to existing documentation Easily capture the diff within an environment variable for use within a custom script: CHANGELOG_DIFF = $( uplift changelog --diff-only --silent ) --exclude \u00b6 By specifying a list of conventional commit prefixes, certain types of commits can be filtered (excluded) from the generated changelog. Optionally include the scope to narrow the range commits that will be excluded. For example, chore will exclude any commit with that prefix, while chore(build) only exclude commits with the build scope. uplift changelog --exclude chore,ci,docs --sort \u00b6 Can be used to change the sort order of commits within each changelog entry. By default entries are sorted in descending ( desc ) order. Latest to oldest commit. Supported values are desc and asc , or any case variant of these. uplift changelog --sort desc SCM Detection \u00b6 During changelog creation uplift will attempt to identify the SCM provider associated with the repository. Upon successful detection, uplift will embed links to tags and commits within the changelog, making it easier to inspect them from within the SCM tool. Supported SCM providers: GitHub (Cloud) GitLab (Cloud) AWS CodeCommit","title":"uplift changelog"},{"location":"cmd/changelog/#uplift-changelog","text":"Create or update an existing changelog with an entry for the latest semantic release. For a first release, all commits between the latest tag and trunk will be written to the changelog. Subsequent entries will contain only commits between release tags. uplift changelog [ FLAGS ]","title":"uplift changelog"},{"location":"cmd/changelog/#flags","text":"","title":"Flags"},{"location":"cmd/changelog/#-all","text":"Generates a changelog from the entire history of the git repository. Provides a great way to migrate an existing changelog process to uplift. uplift changelog --all","title":"--all"},{"location":"cmd/changelog/#-diff-only","text":"Writes the calculated changelog diff to stdout without modifying the current repository. Useful for combining uplift with any other tooling. $ uplift changelog --diff-only \u2022 changelog \u2022 determine changes for release tag = 1 .0.0 \u2022 changeset identified commits = 3 date = 2022 -03-25 tag = 1 .0.0 ## [1.0.0] - 2022-03-25 - ` e988091 ` feat: a brand new feature - ` 11d039b ` ci: speed up existing workflow - ` fad2c38 ` docs: update to existing documentation Easily capture the diff within an environment variable for use within a custom script: CHANGELOG_DIFF = $( uplift changelog --diff-only --silent )","title":"--diff-only"},{"location":"cmd/changelog/#-exclude","text":"By specifying a list of conventional commit prefixes, certain types of commits can be filtered (excluded) from the generated changelog. Optionally include the scope to narrow the range commits that will be excluded. For example, chore will exclude any commit with that prefix, while chore(build) only exclude commits with the build scope. uplift changelog --exclude chore,ci,docs","title":"--exclude"},{"location":"cmd/changelog/#-sort","text":"Can be used to change the sort order of commits within each changelog entry. By default entries are sorted in descending ( desc ) order. Latest to oldest commit. Supported values are desc and asc , or any case variant of these. uplift changelog --sort desc","title":"--sort"},{"location":"cmd/changelog/#scm-detection","text":"During changelog creation uplift will attempt to identify the SCM provider associated with the repository. Upon successful detection, uplift will embed links to tags and commits within the changelog, making it easier to inspect them from within the SCM tool. Supported SCM providers: GitHub (Cloud) GitLab (Cloud) AWS CodeCommit","title":"SCM Detection"},{"location":"cmd/completion/","text":"uplift completion \u00b6 Generates an uplift autocompletion script for your target shell. uplift completion [ COMMAND ] Commands \u00b6 bash \u00b6 To load the completions in your current shell session: source < ( uplift completion bash ) To Load the completions for every new session: Linux \u00b6 uplift completion bash > /etc/bash_completion.d/uplift MacOS \u00b6 uplift completion bash > /usr/local/etc/bash_completion.d/uplift zsh \u00b6 To load the completions in your current shell session: source < ( uplift completion zsh ) To load the completions for every new session: uplift completion zsh > \" ${ fpath [1] } /_uplift\" fish \u00b6 To load the completions in your current shell session: uplift completion fish | source To load the completions for every new session: uplift completion fish > ~/.config/fish/completions/uplift.fish","title":"uplift completion"},{"location":"cmd/completion/#uplift-completion","text":"Generates an uplift autocompletion script for your target shell. uplift completion [ COMMAND ]","title":"uplift completion"},{"location":"cmd/completion/#commands","text":"","title":"Commands"},{"location":"cmd/completion/#bash","text":"To load the completions in your current shell session: source < ( uplift completion bash ) To Load the completions for every new session:","title":"bash"},{"location":"cmd/completion/#linux","text":"uplift completion bash > /etc/bash_completion.d/uplift","title":"Linux"},{"location":"cmd/completion/#macos","text":"uplift completion bash > /usr/local/etc/bash_completion.d/uplift","title":"MacOS"},{"location":"cmd/completion/#zsh","text":"To load the completions in your current shell session: source < ( uplift completion zsh ) To load the completions for every new session: uplift completion zsh > \" ${ fpath [1] } /_uplift\"","title":"zsh"},{"location":"cmd/completion/#fish","text":"To load the completions in your current shell session: uplift completion fish | source To load the completions for every new session: uplift completion fish > ~/.config/fish/completions/uplift.fish","title":"fish"},{"location":"cmd/release/","text":"uplift release \u00b6 Release the next semantic version of your git repository. A release will automatically bump any files and tag the associated commit with the required semantic version uplift release [ FLAGS ] Flags \u00b6 --check \u00b6 Checks if the latest commit contains a conventional commit prefix that will trigger a new release. Returns an exit code of 0 if a release would be carried out. $ uplift release --check \u2022 check release \u2022 retrieved latest commit message = feat: this is a new feature \u2022 detected releasable commit increment = minor --fetch-all \u00b6 Ensure all tags associated with the git repository are fetched before carrying out the release. uplift release --fetch-all --no-prefix \u00b6 Strips the default v prefix from the next calculated semantic version. uplift release --no-prefix Should only need to use this once Once a repository has been tagged with either scheme, e.g. 1.0.0 or v1.0.0 , uplift will continue using it. This flag is most useful when tagging your repository for the first time. --prerelease \u00b6 Append a prerelease suffix to the next calculated semantic version and use it as a prerelease tag. Supporting the Semver 2.0.0 specification, additional labels can be provided for both the prerelease and metadata parts: 1.0.0 -beta.1 1.1.0 -beta.1+20220312 uplift release --prerelease beta.1 --skip-bumps \u00b6 Skip the bumping of any files configured within the uplift configuration file in your repository. uplift release --skip-bumps --skip-changelog \u00b6 Skip the creation or updating of a changelog during the release. uplift release --skip-changelog --exclude \u00b6 By specifying a list of conventional commit prefixes, certain types of commits can be filtered (excluded) from the generated changelog. Optionally include the scope to narrow the range commits that will be excluded. For example, chore will exclude any commit with that prefix, while chore(build) only exclude commits with the build scope. uplift changelog --exclude chore,ci,docs --sort \u00b6 Can be used to change the sort order of commits within each changelog entry. By default entries are sorted in descending ( desc ) order. Latest to oldest commit. Supported values are desc and asc , or any case variant of these. uplift changelog --sort desc","title":"uplift release"},{"location":"cmd/release/#uplift-release","text":"Release the next semantic version of your git repository. A release will automatically bump any files and tag the associated commit with the required semantic version uplift release [ FLAGS ]","title":"uplift release"},{"location":"cmd/release/#flags","text":"","title":"Flags"},{"location":"cmd/release/#-check","text":"Checks if the latest commit contains a conventional commit prefix that will trigger a new release. Returns an exit code of 0 if a release would be carried out. $ uplift release --check \u2022 check release \u2022 retrieved latest commit message = feat: this is a new feature \u2022 detected releasable commit increment = minor","title":"--check"},{"location":"cmd/release/#-fetch-all","text":"Ensure all tags associated with the git repository are fetched before carrying out the release. uplift release --fetch-all","title":"--fetch-all"},{"location":"cmd/release/#-no-prefix","text":"Strips the default v prefix from the next calculated semantic version. uplift release --no-prefix Should only need to use this once Once a repository has been tagged with either scheme, e.g. 1.0.0 or v1.0.0 , uplift will continue using it. This flag is most useful when tagging your repository for the first time.","title":"--no-prefix"},{"location":"cmd/release/#-prerelease","text":"Append a prerelease suffix to the next calculated semantic version and use it as a prerelease tag. Supporting the Semver 2.0.0 specification, additional labels can be provided for both the prerelease and metadata parts: 1.0.0 -beta.1 1.1.0 -beta.1+20220312 uplift release --prerelease beta.1","title":"--prerelease"},{"location":"cmd/release/#-skip-bumps","text":"Skip the bumping of any files configured within the uplift configuration file in your repository. uplift release --skip-bumps","title":"--skip-bumps"},{"location":"cmd/release/#-skip-changelog","text":"Skip the creation or updating of a changelog during the release. uplift release --skip-changelog","title":"--skip-changelog"},{"location":"cmd/release/#-exclude","text":"By specifying a list of conventional commit prefixes, certain types of commits can be filtered (excluded) from the generated changelog. Optionally include the scope to narrow the range commits that will be excluded. For example, chore will exclude any commit with that prefix, while chore(build) only exclude commits with the build scope. uplift changelog --exclude chore,ci,docs","title":"--exclude"},{"location":"cmd/release/#-sort","text":"Can be used to change the sort order of commits within each changelog entry. By default entries are sorted in descending ( desc ) order. Latest to oldest commit. Supported values are desc and asc , or any case variant of these. uplift changelog --sort desc","title":"--sort"},{"location":"cmd/root/","text":"uplift \u00b6 Semantic versioning the easy way. Powered by Conventional Commits. Built for use with CI. uplift [ COMMAND ] Global Flags \u00b6 --config-dir \u00b6 Provide a custom path to a directory containing your uplift configuration file. By default uplift will look in the current directory where it was run. --debug \u00b6 Turn on extra debug output. Good for diving into the details of how uplift works and for reporting any issues that you discover. --dry-run \u00b6 Run uplift without making any changes. A good way for exploring how uplift works. --no-push \u00b6 Prevents uplift from pushing any changes back to your git remote. Any changes made by uplift will remain locally staged. --silent \u00b6 Peace and quiet! Stops uplift from logging anything. A great option when combining uplift with any custom shell scripts. --ignore-detached \u00b6 Suppress the git detached HEAD check within uplift. I have it all under control. --ignore-shallow \u00b6 Suppress the git shallow clone check within uplift. I have it all under control.","title":"uplift"},{"location":"cmd/root/#uplift","text":"Semantic versioning the easy way. Powered by Conventional Commits. Built for use with CI. uplift [ COMMAND ]","title":"uplift"},{"location":"cmd/root/#global-flags","text":"","title":"Global Flags"},{"location":"cmd/root/#-config-dir","text":"Provide a custom path to a directory containing your uplift configuration file. By default uplift will look in the current directory where it was run.","title":"--config-dir"},{"location":"cmd/root/#-debug","text":"Turn on extra debug output. Good for diving into the details of how uplift works and for reporting any issues that you discover.","title":"--debug"},{"location":"cmd/root/#-dry-run","text":"Run uplift without making any changes. A good way for exploring how uplift works.","title":"--dry-run"},{"location":"cmd/root/#-no-push","text":"Prevents uplift from pushing any changes back to your git remote. Any changes made by uplift will remain locally staged.","title":"--no-push"},{"location":"cmd/root/#-silent","text":"Peace and quiet! Stops uplift from logging anything. A great option when combining uplift with any custom shell scripts.","title":"--silent"},{"location":"cmd/root/#-ignore-detached","text":"Suppress the git detached HEAD check within uplift. I have it all under control.","title":"--ignore-detached"},{"location":"cmd/root/#-ignore-shallow","text":"Suppress the git shallow clone check within uplift. I have it all under control.","title":"--ignore-shallow"},{"location":"cmd/tag/","text":"uplift tag \u00b6 Tags a git repository with the next semantic version. The next tag is calculated using the conventional commit message from the last commit. uplift tag [ FLAGS ] Flags \u00b6 --fetch-all \u00b6 Ensure all tags associated with the git repository are fetched before identifying the next tag. uplift tag --fetch-all --next \u00b6 Identify and output the next tag based on the conventional commit message of the last commit. Automatically disables tagging of the git repository. Useful when combining uplift with other external tools. $ uplift tag --next \u2022 latest commit \u2022 retrieved latest commit author = joe.bloggs email = joe.bloggs@example.com message = feat: this is a new feature \u2022 current version \u2022 identified version current = 0 .1.2 \u2022 next version \u2022 identified next version commit = feat: this is a new feature current = 0 .1.2 next = 0 .2.0 \u2022 next commit \u2022 changes will be committed with email = joe.bloggs@example.com message = ci ( uplift ) : uplifted for version 0 .2.0 name = joe.bloggs \u2022 git tag \u2022 identified next tag tag = 0 .2.0 0 .2.0 Easily capture the tag within an environment variable for use within a custom script: NEXT_TAG = $( uplift tag --next --silent ) --no-prefix \u00b6 Strips the default v prefix from the next calculated semantic version. uplift release --no-prefix Should only need to use this once Once a repository has been tagged with either scheme, e.g. 1.0.0 or v1.0.0 , uplift will continue using it. This flag is most useful when tagging your repository for the first time. --prerelease \u00b6 Append a prerelease suffix to the next calculated semantic version and use it as a prerelease tag. Supporting the Semver 2.0.0 specification, additional labels can be provided for both the prerelease and metadata parts: 1.0.0 -beta.1 1.1.0 -beta.1+20220312 $ uplift tag --prerelease beta.1 \u2022 latest commit \u2022 retrieved latest commit author = joe.bloggs email = joe.bloggs@example.com message = feat: this is a new feature \u2022 current version \u2022 identified version current = 0 .1.2 \u2022 next version \u2022 identified next version commit = feat: this is a new feature current = 0 .1.2 next = 0 .2.0-beta.1 \u2022 next commit \u2022 changes will be committed with email = joe.bloggs@example.com message = ci ( uplift ) : uplifted for version 0 .2.0-beta.1 name = joe.bloggs \u2022 git tag \u2022 identified next tag tag = 0 .2.0-beta.1 \u2022 tagged repository with standard tag","title":"uplift tag"},{"location":"cmd/tag/#uplift-tag","text":"Tags a git repository with the next semantic version. The next tag is calculated using the conventional commit message from the last commit. uplift tag [ FLAGS ]","title":"uplift tag"},{"location":"cmd/tag/#flags","text":"","title":"Flags"},{"location":"cmd/tag/#-fetch-all","text":"Ensure all tags associated with the git repository are fetched before identifying the next tag. uplift tag --fetch-all","title":"--fetch-all"},{"location":"cmd/tag/#-next","text":"Identify and output the next tag based on the conventional commit message of the last commit. Automatically disables tagging of the git repository. Useful when combining uplift with other external tools. $ uplift tag --next \u2022 latest commit \u2022 retrieved latest commit author = joe.bloggs email = joe.bloggs@example.com message = feat: this is a new feature \u2022 current version \u2022 identified version current = 0 .1.2 \u2022 next version \u2022 identified next version commit = feat: this is a new feature current = 0 .1.2 next = 0 .2.0 \u2022 next commit \u2022 changes will be committed with email = joe.bloggs@example.com message = ci ( uplift ) : uplifted for version 0 .2.0 name = joe.bloggs \u2022 git tag \u2022 identified next tag tag = 0 .2.0 0 .2.0 Easily capture the tag within an environment variable for use within a custom script: NEXT_TAG = $( uplift tag --next --silent )","title":"--next"},{"location":"cmd/tag/#-no-prefix","text":"Strips the default v prefix from the next calculated semantic version. uplift release --no-prefix Should only need to use this once Once a repository has been tagged with either scheme, e.g. 1.0.0 or v1.0.0 , uplift will continue using it. This flag is most useful when tagging your repository for the first time.","title":"--no-prefix"},{"location":"cmd/tag/#-prerelease","text":"Append a prerelease suffix to the next calculated semantic version and use it as a prerelease tag. Supporting the Semver 2.0.0 specification, additional labels can be provided for both the prerelease and metadata parts: 1.0.0 -beta.1 1.1.0 -beta.1+20220312 $ uplift tag --prerelease beta.1 \u2022 latest commit \u2022 retrieved latest commit author = joe.bloggs email = joe.bloggs@example.com message = feat: this is a new feature \u2022 current version \u2022 identified version current = 0 .1.2 \u2022 next version \u2022 identified next version commit = feat: this is a new feature current = 0 .1.2 next = 0 .2.0-beta.1 \u2022 next commit \u2022 changes will be committed with email = joe.bloggs@example.com message = ci ( uplift ) : uplifted for version 0 .2.0-beta.1 name = joe.bloggs \u2022 git tag \u2022 identified next tag tag = 0 .2.0-beta.1 \u2022 tagged repository with standard tag","title":"--prerelease"},{"location":"config/about/","text":"About \u00b6 Uplift can be customised through a configuration file. In fact, uplift supports multiple default naming conventions. So take your pick! .uplift.yml .uplift.yaml uplift.yml uplift.yaml Try it without a config file Uplift is continuously being developed to work without a configuration file by using sensible defaults. We want uplift to be incredibly easy to use! \ud83c\udfc6","title":"About"},{"location":"config/about/#about","text":"Uplift can be customised through a configuration file. In fact, uplift supports multiple default naming conventions. So take your pick! .uplift.yml .uplift.yaml uplift.yml uplift.yaml Try it without a config file Uplift is continuously being developed to work without a configuration file by using sensible defaults. We want uplift to be incredibly easy to use! \ud83c\udfc6","title":"About"},{"location":"config/basics/","text":"Basics \u00b6 Ideally none of these values should need to be set as uplift will always use what we believe to be sensible default values. commitMessage \u00b6 1 2 3 4 5 6 7 8 9 # .uplift.yml # Changes the default commit message used by uplift when committing any staged # changes. If carrying out a full release, uplift will have staged and committed # any changelog creation or amendments, and any file within the repository that # has been bumped. # # Defaults to ci(uplift): uplifted for version <LATEST_TAG> commitMessage : \"chore: a custom commit message\" commitAuthor \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # .uplift.yml # Changes the commit author used by uplift when committing any staged changes. # # Defaults to the Uplift Bot: uplift-bot <uplift@gembaadvantage.com> commitAuthor : # Name of the author # # Defaults to the author name within the last commit name : \"joe.bloggs\" # Email of the author # # Defaults to the author email within the last commit email : \"joe.bloggs@gmail.com\" annotatedTags \u00b6 1 2 3 4 5 6 7 8 9 # .uplift.yml # Use annotated tags instead of lightweight tags when tagging a new semantic # version. An annotated tag is treated like a regular commit by git and contains # both author details and a commit message. Uplift will either use its defaults # or the custom commit details provided when generated the annotated tag. # # Defaults to false annotatedTags : true What are Annotated Tags? To find out more about annotated tags I recommend reading the official Git documentation","title":"Basics"},{"location":"config/basics/#basics","text":"Ideally none of these values should need to be set as uplift will always use what we believe to be sensible default values.","title":"Basics"},{"location":"config/basics/#commitmessage","text":"1 2 3 4 5 6 7 8 9 # .uplift.yml # Changes the default commit message used by uplift when committing any staged # changes. If carrying out a full release, uplift will have staged and committed # any changelog creation or amendments, and any file within the repository that # has been bumped. # # Defaults to ci(uplift): uplifted for version <LATEST_TAG> commitMessage : \"chore: a custom commit message\"","title":"commitMessage"},{"location":"config/basics/#commitauthor","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # .uplift.yml # Changes the commit author used by uplift when committing any staged changes. # # Defaults to the Uplift Bot: uplift-bot <uplift@gembaadvantage.com> commitAuthor : # Name of the author # # Defaults to the author name within the last commit name : \"joe.bloggs\" # Email of the author # # Defaults to the author email within the last commit email : \"joe.bloggs@gmail.com\"","title":"commitAuthor"},{"location":"config/basics/#annotatedtags","text":"1 2 3 4 5 6 7 8 9 # .uplift.yml # Use annotated tags instead of lightweight tags when tagging a new semantic # version. An annotated tag is treated like a regular commit by git and contains # both author details and a commit message. Uplift will either use its defaults # or the custom commit details provided when generated the annotated tag. # # Defaults to false annotatedTags : true What are Annotated Tags? To find out more about annotated tags I recommend reading the official Git documentation","title":"annotatedTags"},{"location":"config/bumping/","text":"File Bumping \u00b6 Uplift can bump the semantic version within any file in your repository using the currently supported schemes. Even though these configs are shown separately, you are free to mix and match within your uplift configuration file. regex \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # .uplift.yml bumps : - # The path of the file relative to where uplift is executed file : ./chart/my-chart/Chart.yaml # A regex matcher should be used when bumping the file. Multiple regex # matches are supported. Each will be carried out in the order they are # defined here. All matches must succeed for the file to be bumped # # Defaults to no matchers regex : - # The regex that should be used for matching the version that # will be replaced within the file pattern : \"version: $VERSION\" # If the matched version in the file should be replaced with a semantic version. # This will strip any 'v' prefix if needed # # Defaults to false semver : true # The number of times any matched version should be replaced # # Defaults to 0, which replaces all matches count : 1 $VERSION \u00b6 $VERSION is a placeholder and will match any semantic version, including a version with an optional v prefix. json \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # .uplift.yml bumps : - # The path of the file relative to where uplift is executed file : ./package.json # A JSON path matcher should be used when bumping the file. Multiple path # matches are supported. Each will be carried out in the order they are # defined here. All matches must succeed for the file to be bumped. # JSON path syntax is based on https://github.com/tidwall/sjson # # Defaults to no matchers json : - # A JSON path that will be used for matching the version that # will be replaced within the file path : \"version\" # If the matched version in the file should be replaced with a semantic version. # This will strip any 'v' prefix if needed # # Defaults to false semver : true Need more complicated JSON Paths? Uplift uses SJSON for setting values through JSON paths. If you need to write more complex JSON paths, don't forget to look at their documentation","title":"File Bumping"},{"location":"config/bumping/#file-bumping","text":"Uplift can bump the semantic version within any file in your repository using the currently supported schemes. Even though these configs are shown separately, you are free to mix and match within your uplift configuration file.","title":"File Bumping"},{"location":"config/bumping/#regex","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # .uplift.yml bumps : - # The path of the file relative to where uplift is executed file : ./chart/my-chart/Chart.yaml # A regex matcher should be used when bumping the file. Multiple regex # matches are supported. Each will be carried out in the order they are # defined here. All matches must succeed for the file to be bumped # # Defaults to no matchers regex : - # The regex that should be used for matching the version that # will be replaced within the file pattern : \"version: $VERSION\" # If the matched version in the file should be replaced with a semantic version. # This will strip any 'v' prefix if needed # # Defaults to false semver : true # The number of times any matched version should be replaced # # Defaults to 0, which replaces all matches count : 1","title":"regex"},{"location":"config/bumping/#version","text":"$VERSION is a placeholder and will match any semantic version, including a version with an optional v prefix.","title":"$VERSION"},{"location":"config/bumping/#json","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # .uplift.yml bumps : - # The path of the file relative to where uplift is executed file : ./package.json # A JSON path matcher should be used when bumping the file. Multiple path # matches are supported. Each will be carried out in the order they are # defined here. All matches must succeed for the file to be bumped. # JSON path syntax is based on https://github.com/tidwall/sjson # # Defaults to no matchers json : - # A JSON path that will be used for matching the version that # will be replaced within the file path : \"version\" # If the matched version in the file should be replaced with a semantic version. # This will strip any 'v' prefix if needed # # Defaults to false semver : true Need more complicated JSON Paths? Uplift uses SJSON for setting values through JSON paths. If you need to write more complex JSON paths, don't forget to look at their documentation","title":"json"},{"location":"config/changelog/","text":"Changelog \u00b6 Uplift can generate and maintain a changelog within your repository for you. We believe that in most situations, these values will never need to be set as uplift uses sensible defaults. sort \u00b6 1 2 3 4 5 6 7 8 # .uplift.yml changelog : # Change the sort order of the commits within each changelog entry. Supported # values are asc or desc (case is ignored) # # Defaults to desc (descending order) to mirror the default behaviour of \"git log\" sort : asc exclude \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 # .uplift.yml changelog : # A list of commits to exclude during the creation of a changelog. Provide a list # of conventional commit prefixes to filter on. Auto-generated commits from uplift # (with the prefix ci(uplift)) will always be excluded # # Defaults to including all commits within the generated changelog exclude : - chore(deps) - docs - ci","title":"Changelog"},{"location":"config/changelog/#changelog","text":"Uplift can generate and maintain a changelog within your repository for you. We believe that in most situations, these values will never need to be set as uplift uses sensible defaults.","title":"Changelog"},{"location":"config/changelog/#sort","text":"1 2 3 4 5 6 7 8 # .uplift.yml changelog : # Change the sort order of the commits within each changelog entry. Supported # values are asc or desc (case is ignored) # # Defaults to desc (descending order) to mirror the default behaviour of \"git log\" sort : asc","title":"sort"},{"location":"config/changelog/#exclude","text":"1 2 3 4 5 6 7 8 9 10 11 12 # .uplift.yml changelog : # A list of commits to exclude during the creation of a changelog. Provide a list # of conventional commit prefixes to filter on. Auto-generated commits from uplift # (with the prefix ci(uplift)) will always be excluded # # Defaults to including all commits within the generated changelog exclude : - chore(deps) - docs - ci","title":"exclude"},{"location":"config/env/","text":"Environment Variables \u00b6 Define environment variables that will be made available to all hooks. Environment variables can be individually listed or defined within dotenv 1 (.env) files. Uplift will merge all environment variables with any pre-existing system ones. 1 2 3 4 5 6 7 # .uplift.yml env : - VARIABLE=VALUE - ANOTHER_VARIABLE=ANOTHER VALUE - .env - path/to/other.env Dotenv support is provided through the github.com/joho/godotenv library \u21a9","title":"Environment Variables"},{"location":"config/env/#environment-variables","text":"Define environment variables that will be made available to all hooks. Environment variables can be individually listed or defined within dotenv 1 (.env) files. Uplift will merge all environment variables with any pre-existing system ones. 1 2 3 4 5 6 7 # .uplift.yml env : - VARIABLE=VALUE - ANOTHER_VARIABLE=ANOTHER VALUE - .env - path/to/other.env Dotenv support is provided through the github.com/joho/godotenv library \u21a9","title":"Environment Variables"},{"location":"config/git/","text":"Git \u00b6 Uplift requires a git repository to be cloned in a certain way to ensure all features run as expected. However, since only a subset of features may be needed, existing git checks can be suppressed when needed. ignoreDetached \u00b6 1 2 3 4 5 6 7 8 9 # .uplift.yml git : # A flag for suppressing the git detached HEAD repository check. If set to # true, uplift will report a warning while running, otherwise uplift will # raise an error and stop. # # Defaults to false ignoreDetached : true ignoreShallow \u00b6 1 2 3 4 5 6 7 8 9 # .uplift.yml git : # A flag for suppressing the git shallow repository check. If set to true, # uplift will report a warning while running, otherwise uplift will raise # an error and stop. # # Defaults to false ignoreShallow : true","title":"Git"},{"location":"config/git/#git","text":"Uplift requires a git repository to be cloned in a certain way to ensure all features run as expected. However, since only a subset of features may be needed, existing git checks can be suppressed when needed.","title":"Git"},{"location":"config/git/#ignoredetached","text":"1 2 3 4 5 6 7 8 9 # .uplift.yml git : # A flag for suppressing the git detached HEAD repository check. If set to # true, uplift will report a warning while running, otherwise uplift will # raise an error and stop. # # Defaults to false ignoreDetached : true","title":"ignoreDetached"},{"location":"config/git/#ignoreshallow","text":"1 2 3 4 5 6 7 8 9 # .uplift.yml git : # A flag for suppressing the git shallow repository check. If set to true, # uplift will report a warning while running, otherwise uplift will raise # an error and stop. # # Defaults to false ignoreShallow : true","title":"ignoreShallow"},{"location":"config/hooks/","text":"Hooks \u00b6 Provides a mechanism to extend the functionality of uplift through adhoc shell commands and scripts 1 . Only the before hook precedes the git checks within uplift. All temporary files must therefore be ignored using a .gitignore file, otherwise the repository will be deemed in a dirty state and the release will stop. Hooks tied to either of the bump , changelog or tag operations will be skipped along with its counterpart when needed by uplift. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # .uplift.yml # All hooks default to an empty list and will be skipped hooks : # A list of shell commands or scripts to execute before uplift runs # any tasks within its release workflow before : - npm install - go mod tidy - cargo fetch - ENV=VALUE ./my-custom-script.sh - bash path//to//my-custom-script.sh # (1) # A list of shell commands or scripts to execute before uplift bumps # any configured file beforeBump : - ... # A list of shell commands or scripts to execute before uplift runs # its changelog generation task beforeChangelog : - ... # A list of shell commands or scripts to execute before uplift tags # the repository with the next semantic release beforeTag : # A list of shell commands or scripts to execute after uplift # completes all tasks within its release workflow after : - ... # A list of shell commands or scripts to execute after uplift bumps # any configured file afterBump : - ... # A list of shell commands or scripts to execute after uplift generates # a new changelog afterChangelog : - ... # A list of shell commands or scripts to execute after uplift tags # the repository with the next semantic release afterTag : - ... An example of using POSIX based windows commands through the mvdan/sh GitHub library. Pay special attention to the use of // when specifying a path Need extra output? Use the --debug flag to print output from any of the executed shell commands or scripts Interpretation and execution of shell commands and scripts is carried out through the mvdan/sh GitHub library. \u21a9","title":"Hooks"},{"location":"config/hooks/#hooks","text":"Provides a mechanism to extend the functionality of uplift through adhoc shell commands and scripts 1 . Only the before hook precedes the git checks within uplift. All temporary files must therefore be ignored using a .gitignore file, otherwise the repository will be deemed in a dirty state and the release will stop. Hooks tied to either of the bump , changelog or tag operations will be skipped along with its counterpart when needed by uplift. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # .uplift.yml # All hooks default to an empty list and will be skipped hooks : # A list of shell commands or scripts to execute before uplift runs # any tasks within its release workflow before : - npm install - go mod tidy - cargo fetch - ENV=VALUE ./my-custom-script.sh - bash path//to//my-custom-script.sh # (1) # A list of shell commands or scripts to execute before uplift bumps # any configured file beforeBump : - ... # A list of shell commands or scripts to execute before uplift runs # its changelog generation task beforeChangelog : - ... # A list of shell commands or scripts to execute before uplift tags # the repository with the next semantic release beforeTag : # A list of shell commands or scripts to execute after uplift # completes all tasks within its release workflow after : - ... # A list of shell commands or scripts to execute after uplift bumps # any configured file afterBump : - ... # A list of shell commands or scripts to execute after uplift generates # a new changelog afterChangelog : - ... # A list of shell commands or scripts to execute after uplift tags # the repository with the next semantic release afterTag : - ... An example of using POSIX based windows commands through the mvdan/sh GitHub library. Pay special attention to the use of // when specifying a path Need extra output? Use the --debug flag to print output from any of the executed shell commands or scripts Interpretation and execution of shell commands and scripts is carried out through the mvdan/sh GitHub library. \u21a9","title":"Hooks"},{"location":"faq/gitdetached/","text":"Git repository has a detached HEAD \u00b6 Uplift may not run reliably 1 against a git repository that is checked out with a detached HEAD. A detached HEAD occurs when a checkout is made against a specific commit, rather than a branch. Many of the documented CI providers use this strategy to ensure a build runs against a commit that triggered it. While in this state, uplift cannot push changes back to the main branch. uplift cannot reliably run when the repository is in a detached HEAD state. Some features will not run as expected. To suppress this error, use the '--ignore-detached' flag, or set the required config. For further details visit: https://upliftci.dev/faq/gitdetached To resolve this error, you have the following options: If you are using a documented CI provider, view the example YAML configuration, to ensure your repository is in the right state before running uplift. If your CI provider isn't listed, please consult their documentation. We would appreciate it, if you contributed back with your findings. You can suppress the error by either setting the global --ignore-detached flag or by disabling it in the uplift config file. Features such as file bumping and changelog management will be impacted. \u21a9","title":"Git Repository has a Detached HEAD"},{"location":"faq/gitdetached/#git-repository-has-a-detached-head","text":"Uplift may not run reliably 1 against a git repository that is checked out with a detached HEAD. A detached HEAD occurs when a checkout is made against a specific commit, rather than a branch. Many of the documented CI providers use this strategy to ensure a build runs against a commit that triggered it. While in this state, uplift cannot push changes back to the main branch. uplift cannot reliably run when the repository is in a detached HEAD state. Some features will not run as expected. To suppress this error, use the '--ignore-detached' flag, or set the required config. For further details visit: https://upliftci.dev/faq/gitdetached To resolve this error, you have the following options: If you are using a documented CI provider, view the example YAML configuration, to ensure your repository is in the right state before running uplift. If your CI provider isn't listed, please consult their documentation. We would appreciate it, if you contributed back with your findings. You can suppress the error by either setting the global --ignore-detached flag or by disabling it in the uplift config file. Features such as file bumping and changelog management will be impacted. \u21a9","title":"Git repository has a detached HEAD"},{"location":"faq/gitdirty/","text":"Git Repository is in a Dirty State \u00b6 Uplift won't run against a git repository that has un-staged and/or un-committed files, typically know as a dirty state. Uplift requires a clean git working directory. uplift cannot reliably run if the repository is in a dirty state. Changes detected: M main.go ?? coverage.out Please check and resolve the status of these files before retrying. For further details visit: https://upliftci.dev/faq/gitdirty As you can see the error message shows the offending files and their current git status . To resolve the error, you have the following options: Add a .gitignore file to your repository to ensure these files are no longer tracked Change your CI approach to ensure no tracked files are modified or temporary files are generated before uplift is run","title":"Git Repository is in a Dirty State"},{"location":"faq/gitdirty/#git-repository-is-in-a-dirty-state","text":"Uplift won't run against a git repository that has un-staged and/or un-committed files, typically know as a dirty state. Uplift requires a clean git working directory. uplift cannot reliably run if the repository is in a dirty state. Changes detected: M main.go ?? coverage.out Please check and resolve the status of these files before retrying. For further details visit: https://upliftci.dev/faq/gitdirty As you can see the error message shows the offending files and their current git status . To resolve the error, you have the following options: Add a .gitignore file to your repository to ensure these files are no longer tracked Change your CI approach to ensure no tracked files are modified or temporary files are generated before uplift is run","title":"Git Repository is in a Dirty State"},{"location":"faq/gitshallow/","text":"Git Repository contains a Shallow Clone \u00b6 Uplift may not run reliably 1 against a git repository that contains a shallow clone. A shallow clone will result in a git repository containing history about the latest commit only. Many of the documented CI providers use this strategy to improve the efficiency of a clone, especially for large repositories. uplift cannot reliably run against a shallow clone of the repository. Some features may not work as expected. To suppress this error, use the '--ignore-shallow' flag, or set the required config. For further details visit: https://upliftci.dev/faq/gitshallow To resolve this error, you have the following options: If you are using a documented CI provider, view the example YAML configuration, to ensure your repository is in the right state before running uplift. If your CI provider isn't listed, please consult their documentation. We would appreciate it, if you contributed back with your findings. You can suppress the error by either setting the global --ignore-shallow flag or by disabling it in the uplift config file. Depending on the clone strategy of your CI provider, many, if not all features of uplift will be impacted. \u21a9","title":"Git Repository contains a Shallow Clone"},{"location":"faq/gitshallow/#git-repository-contains-a-shallow-clone","text":"Uplift may not run reliably 1 against a git repository that contains a shallow clone. A shallow clone will result in a git repository containing history about the latest commit only. Many of the documented CI providers use this strategy to improve the efficiency of a clone, especially for large repositories. uplift cannot reliably run against a shallow clone of the repository. Some features may not work as expected. To suppress this error, use the '--ignore-shallow' flag, or set the required config. For further details visit: https://upliftci.dev/faq/gitshallow To resolve this error, you have the following options: If you are using a documented CI provider, view the example YAML configuration, to ensure your repository is in the right state before running uplift. If your CI provider isn't listed, please consult their documentation. We would appreciate it, if you contributed back with your findings. You can suppress the error by either setting the global --ignore-shallow flag or by disabling it in the uplift config file. Depending on the clone strategy of your CI provider, many, if not all features of uplift will be impacted. \u21a9","title":"Git Repository contains a Shallow Clone"},{"location":"scm/about/","text":"SCM Detection \u00b6 Uplift uses SCM ( source code management ) detection to identify repositories from GitHub, GitLab, CodeCommit and Gitea ( pronounced git-tea ). From this detection, uplift provides the following features: Dynamic links within changelogs Keep on eye on this space More features will be added as uplift dives more into this space","title":"About"},{"location":"scm/about/#scm-detection","text":"Uplift uses SCM ( source code management ) detection to identify repositories from GitHub, GitLab, CodeCommit and Gitea ( pronounced git-tea ). From this detection, uplift provides the following features: Dynamic links within changelogs Keep on eye on this space More features will be added as uplift dives more into this space","title":"SCM Detection"},{"location":"scm/gitea/","text":"Gitea \u00b6 As Gitea is a self-hosted SCM, custom configuration is required to support detection. 1 2 3 4 5 6 7 8 9 # uplift.yml gitea : # The URL of the self-hosted instance of Gitea. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitea.com","title":"Gitea"},{"location":"scm/gitea/#gitea","text":"As Gitea is a self-hosted SCM, custom configuration is required to support detection. 1 2 3 4 5 6 7 8 9 # uplift.yml gitea : # The URL of the self-hosted instance of Gitea. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitea.com","title":"Gitea"},{"location":"scm/github/","text":"GitHub \u00b6 Uplift comes with built-in detection for GitHub (SaaS). However, when using GitHub Enterprise , custom configuration is needed. 1 2 3 4 5 6 7 8 9 # uplift.yml github : # The URL of the enterprise instance of GitHub. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.github.com","title":"GitHub"},{"location":"scm/github/#github","text":"Uplift comes with built-in detection for GitHub (SaaS). However, when using GitHub Enterprise , custom configuration is needed. 1 2 3 4 5 6 7 8 9 # uplift.yml github : # The URL of the enterprise instance of GitHub. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.github.com","title":"GitHub"},{"location":"scm/gitlab/","text":"GitLab \u00b6 Uplift comes with built-in detection for GitLab (SaaS). However, when using Self-Managed GitLab , custom configuration is needed. 1 2 3 4 5 6 7 8 9 # uplift.yml gitlab : # The URL of the self-managed instance of GitLab. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitlab.com","title":"GitLab"},{"location":"scm/gitlab/#gitlab","text":"Uplift comes with built-in detection for GitLab (SaaS). However, when using Self-Managed GitLab , custom configuration is needed. 1 2 3 4 5 6 7 8 9 # uplift.yml gitlab : # The URL of the self-managed instance of GitLab. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitlab.com","title":"GitLab"}]}