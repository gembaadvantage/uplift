{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Semantic Versioning the Easy Way \u00b6 By harnessing the power of Conventional Commits , Uplift simplifies the release management of your project through your use of commit messages. Built for Continuous Integration (CI), Uplift is incredibly simple to use, and its modular design allows you to choose which release cycle features you want to incorporate into your workflow. It adheres to the Semantic Versioning specification and plays nicely with other tools. And it's built using Go so that you can install it anywhere! Features \u00b6 File Bumping: Update the semantic version within any configured file Changelog Generation: Creates and updates a changelog for each semantic release Repository Tagging: Tags your repository with the next semantic version Uplift \u2764\ufe0f Conventional Commits","title":"Home"},{"location":"#semantic-versioning-the-easy-way","text":"By harnessing the power of Conventional Commits , Uplift simplifies the release management of your project through your use of commit messages. Built for Continuous Integration (CI), Uplift is incredibly simple to use, and its modular design allows you to choose which release cycle features you want to incorporate into your workflow. It adheres to the Semantic Versioning specification and plays nicely with other tools. And it's built using Go so that you can install it anywhere!","title":"Semantic Versioning the Easy Way"},{"location":"#features","text":"File Bumping: Update the semantic version within any configured file Changelog Generation: Creates and updates a changelog for each semantic release Repository Tagging: Tags your repository with the next semantic version Uplift \u2764\ufe0f Conventional Commits","title":"Features"},{"location":"bumping-files/","text":"Bumping your Files \u00b6 If you only need to bump the semantic version within specific files, Uplift has you covered. A .uplift.yml configuration file is required for this to work. Bumping files using JSON Paths and Regex are currently supported. 1 2 3 4 5 6 7 8 9 10 11 12 13 # .uplift.yml bumps : - file : package.json json : - path : \"version\" semver : true - file : chart/my-chart/Chart.yaml regex : - pattern : \"version: $VERSION\" semver : true count : 1 uplift bump Please review our comprehensive guide on configuring file bumps. \u2764\ufe0f to the github.com/tidwall/sjson library. The $VERSION Token \u00b6 Writing a regex can be challenging at most times, so Uplift provides the $VERSION token for matching a semantic version with an optional v prefix. You can include this in any pattern you define within your config. Prerelease Support \u00b6 Experimental Uplift has early support for bumping files with prerelease metadata. You will need to calculate this upfront. uplift bump --prerelease beta.1+20220930","title":"Bumping your Files"},{"location":"bumping-files/#bumping-your-files","text":"If you only need to bump the semantic version within specific files, Uplift has you covered. A .uplift.yml configuration file is required for this to work. Bumping files using JSON Paths and Regex are currently supported. 1 2 3 4 5 6 7 8 9 10 11 12 13 # .uplift.yml bumps : - file : package.json json : - path : \"version\" semver : true - file : chart/my-chart/Chart.yaml regex : - pattern : \"version: $VERSION\" semver : true count : 1 uplift bump Please review our comprehensive guide on configuring file bumps. \u2764\ufe0f to the github.com/tidwall/sjson library.","title":"Bumping your Files"},{"location":"bumping-files/#the-version-token","text":"Writing a regex can be challenging at most times, so Uplift provides the $VERSION token for matching a semantic version with an optional v prefix. You can include this in any pattern you define within your config.","title":"The $VERSION Token"},{"location":"bumping-files/#prerelease-support","text":"Experimental Uplift has early support for bumping files with prerelease metadata. You will need to calculate this upfront. uplift bump --prerelease beta.1+20220930","title":"Prerelease Support"},{"location":"changelog/","text":"Generating a Changelog \u00b6 Uplift can generate or amend a changelog ( CHANGELOG.md ) for your repository based on the Keep a Changelog format. uplift changelog Excluding Commits \u00b6 You can exclude commits from the changelog by specifying a list of commit prefixes. uplift changelog --exclude chore,ci,test Changing the Commit Order \u00b6 Commits are written to a changelog in descending order, reflecting the behaviour of git log . Change this order by specifying asc (case insensitive). uplift changelog --sort asc Output the Changelog Diff \u00b6 You can output the calculated changelog difference ( diff ) to stdout without modifying the local repository. uplift changelog --diff-only Migrate an Existing Repository \u00b6 Experimental If your repository does not contain a CHANGELOG.md file, you can generate one that spans its entire history. A word of warning, this does require a tagging structure to be in place. uplift changelog --all","title":"Generating a Changelog"},{"location":"changelog/#generating-a-changelog","text":"Uplift can generate or amend a changelog ( CHANGELOG.md ) for your repository based on the Keep a Changelog format. uplift changelog","title":"Generating a Changelog"},{"location":"changelog/#excluding-commits","text":"You can exclude commits from the changelog by specifying a list of commit prefixes. uplift changelog --exclude chore,ci,test","title":"Excluding Commits"},{"location":"changelog/#changing-the-commit-order","text":"Commits are written to a changelog in descending order, reflecting the behaviour of git log . Change this order by specifying asc (case insensitive). uplift changelog --sort asc","title":"Changing the Commit Order"},{"location":"changelog/#output-the-changelog-diff","text":"You can output the calculated changelog difference ( diff ) to stdout without modifying the local repository. uplift changelog --diff-only","title":"Output the Changelog Diff"},{"location":"changelog/#migrate-an-existing-repository","text":"Experimental If your repository does not contain a CHANGELOG.md file, you can generate one that spans its entire history. A word of warning, this does require a tagging structure to be in place. uplift changelog --all","title":"Migrate an Existing Repository"},{"location":"commit-signing/","text":"Signing your Commits \u00b6 Experimental It is best security practice to sign commits with a GPG key to prove their authenticity. Uplift detects the presence of a GPG key through environment variables and will automatically sign any commit. UPLIFT_GPG_KEY UPLIFT_GPG_PASSPHRASE UPLIFT_GPG_FINGERPRINT Generating a GPG Key \u00b6 gpg --full-generate-key Follow the on-screen prompts, selecting RSA and RSA (default) and specifying a key length of 4096 . Don't forget to use a strong passphrase. Take note of the fingerprint, which is FDA7347ACCE12A6CEBED57727B0EDBE188EE9114 , in this instance: Exporting a GPG Key \u00b6 Please export your GPG key using the ASCII Armor format. Enter your passphrase when prompted. gpg --armor --export-secret-key FDA7347ACCE12A6CEBED57727B0EDBE188EE9114 You can also base64 encode the output: gpg --armor --export-secret-key FDA7347ACCE12A6CEBED57727B0EDBE188EE9114 | base64 Limitations \u00b6 Signing-only sub-keys are not supported.","title":"Signing Commits"},{"location":"commit-signing/#signing-your-commits","text":"Experimental It is best security practice to sign commits with a GPG key to prove their authenticity. Uplift detects the presence of a GPG key through environment variables and will automatically sign any commit. UPLIFT_GPG_KEY UPLIFT_GPG_PASSPHRASE UPLIFT_GPG_FINGERPRINT","title":"Signing your Commits"},{"location":"commit-signing/#generating-a-gpg-key","text":"gpg --full-generate-key Follow the on-screen prompts, selecting RSA and RSA (default) and specifying a key length of 4096 . Don't forget to use a strong passphrase. Take note of the fingerprint, which is FDA7347ACCE12A6CEBED57727B0EDBE188EE9114 , in this instance:","title":"Generating a GPG Key"},{"location":"commit-signing/#exporting-a-gpg-key","text":"Please export your GPG key using the ASCII Armor format. Enter your passphrase when prompted. gpg --armor --export-secret-key FDA7347ACCE12A6CEBED57727B0EDBE188EE9114 You can also base64 encode the output: gpg --armor --export-secret-key FDA7347ACCE12A6CEBED57727B0EDBE188EE9114 | base64","title":"Exporting a GPG Key"},{"location":"commit-signing/#limitations","text":"Signing-only sub-keys are not supported.","title":"Limitations"},{"location":"conventional-commits/","text":"Why use Conventional Commits? \u00b6 Conventional Commits is a specification designed to introduce human and machine-readable meaning to commit messages, enabling automated tooling such as Uplift for managing releases. A user prefixes their commit with a type to describe their intent, and these labels form a direct relationship with Semantic Versioning . The specification adopts the Angular convention, and so does Uplift. Semantic Versioning Types \u00b6 fix: A bug fix triggers a patch semantic version bump 0.1.0 ~> 0.1.1 feat: A new feature triggers a minor semantic version bump 0.1.0 ~> 0.2.0 feat ! : A breaking change triggers a major semantic version bump 0.1.0 ~> 1.0.0 1 Additional Angular Types \u00b6 Uplift supports all the additional Angular types, chore: , ci: , docs: , style: , refactor: , perf: and test: . How Uplift Scans Commits \u00b6 When determining the next semantic version, all commit messages for a release are scanned for the highest possible increment (Patch, Minor or Major). docs: add documentation for new exciting feature ci: build and test documentation within pipeline feat: shiny new feature <-- largest increment fix: fixed another bug found by user fix: fixed bug found by user In the above example, if the latest tag were 0.1.0 it would be incremented to 0.2.0 . Users can also add a BREAKING CHANGE footer to their commit message. \u21a9","title":"Conventional Commits"},{"location":"conventional-commits/#why-use-conventional-commits","text":"Conventional Commits is a specification designed to introduce human and machine-readable meaning to commit messages, enabling automated tooling such as Uplift for managing releases. A user prefixes their commit with a type to describe their intent, and these labels form a direct relationship with Semantic Versioning . The specification adopts the Angular convention, and so does Uplift.","title":"Why use Conventional Commits?"},{"location":"conventional-commits/#semantic-versioning-types","text":"fix: A bug fix triggers a patch semantic version bump 0.1.0 ~> 0.1.1 feat: A new feature triggers a minor semantic version bump 0.1.0 ~> 0.2.0 feat ! : A breaking change triggers a major semantic version bump 0.1.0 ~> 1.0.0 1","title":"Semantic Versioning Types"},{"location":"conventional-commits/#additional-angular-types","text":"Uplift supports all the additional Angular types, chore: , ci: , docs: , style: , refactor: , perf: and test: .","title":"Additional Angular Types"},{"location":"conventional-commits/#how-uplift-scans-commits","text":"When determining the next semantic version, all commit messages for a release are scanned for the highest possible increment (Patch, Minor or Major). docs: add documentation for new exciting feature ci: build and test documentation within pipeline feat: shiny new feature <-- largest increment fix: fixed another bug found by user fix: fixed bug found by user In the above example, if the latest tag were 0.1.0 it would be incremented to 0.2.0 . Users can also add a BREAKING CHANGE footer to their commit message. \u21a9","title":"How Uplift Scans Commits"},{"location":"first-release/","text":"Creating your First Release \u00b6 A release comprises three stages: Patching the semantic version within a set of configured files ( known as file bumping ) Generating a changelog Tagging the repository Uplift Configuration \u00b6 File bumping currently requires a configuration file named .uplift.yml . Please review our guide on configuring file bumps for comprehensive details. 1 2 3 4 5 6 7 8 # .uplift.yml # Example of bumping a package.json file bumps : - file : package.json json : - path : \"version\" semver : true Go, create that release \ud83d\ude80 uplift release Skipping Stages \u00b6 You can skip file bumping --skip-bumps and changelog creation --skip-changelog by using either of the supported flags.","title":"Creating your First Release"},{"location":"first-release/#creating-your-first-release","text":"A release comprises three stages: Patching the semantic version within a set of configured files ( known as file bumping ) Generating a changelog Tagging the repository","title":"Creating your First Release"},{"location":"first-release/#uplift-configuration","text":"File bumping currently requires a configuration file named .uplift.yml . Please review our guide on configuring file bumps for comprehensive details. 1 2 3 4 5 6 7 8 # .uplift.yml # Example of bumping a package.json file bumps : - file : package.json json : - path : \"version\" semver : true Go, create that release \ud83d\ude80 uplift release","title":"Uplift Configuration"},{"location":"first-release/#skipping-stages","text":"You can skip file bumping --skip-bumps and changelog creation --skip-changelog by using either of the supported flags.","title":"Skipping Stages"},{"location":"license/","text":"MIT License Copyright (c) 2021-2022 Gemba Advantage Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"tagging/","text":"Tagging your Repository \u00b6 If you only need to manage the tags on your repository, Uplift has you covered. uplift tag If you don't want the v prefix, no problem; remove it by using the --strip-prefix flag. Annotated Tags \u00b6 Experimental Lightweight tags are created by default, equivalent to running git tag against your repository. If you need something heavier, such as an annotated tag, modify your configuration file: 1 2 3 # .uplift.yml annotatedTags : true Prerelease Support \u00b6 Experimental Uplift has early support for tagging a repository with prerelease metadata. You will need to calculate this upfront. uplift tag --prerelease beta.1+20220930","title":"Tagging your Repository"},{"location":"tagging/#tagging-your-repository","text":"If you only need to manage the tags on your repository, Uplift has you covered. uplift tag If you don't want the v prefix, no problem; remove it by using the --strip-prefix flag.","title":"Tagging your Repository"},{"location":"tagging/#annotated-tags","text":"Experimental Lightweight tags are created by default, equivalent to running git tag against your repository. If you need something heavier, such as an annotated tag, modify your configuration file: 1 2 3 # .uplift.yml annotatedTags : true","title":"Annotated Tags"},{"location":"tagging/#prerelease-support","text":"Experimental Uplift has early support for tagging a repository with prerelease metadata. You will need to calculate this upfront. uplift tag --prerelease beta.1+20220930","title":"Prerelease Support"},{"location":"uplift-bot/","text":"Your friendly neighbourhood Uplift Bot \u00b6 Say hi to the Uplift-Bot , author of all commits and annotated tags within Uplift. By default, Uplift commits with the following details: uplift-bot <uplift-bot@gembaadvantage.com> ci(uplift): uplifted for version v0.1.0","title":"Hello Uplift-Bot"},{"location":"uplift-bot/#your-friendly-neighbourhood-uplift-bot","text":"Say hi to the Uplift-Bot , author of all commits and annotated tags within Uplift. By default, Uplift commits with the following details: uplift-bot <uplift-bot@gembaadvantage.com> ci(uplift): uplifted for version v0.1.0","title":"Your friendly neighbourhood Uplift Bot"},{"location":"ci/awscodebuild/","text":"AWS CodeBuild \u00b6 AWS CodeBuild can be used as a standalone service when running Uplift. This guide assumes CodeBuild was configured manually through the AWS Console and focuses on the gotchas 1 . CodeBuild will always receive a git clone with a detached HEAD. By default, Uplift will error in this scenario. When performing a release, this will need to be resolved through a git checkout . The CODEBUILD_SOURCE_VERSION variable contains the necessary git reference. IAM \u00b6 Additional permissions are needed to pull and push code within AWS CodeBuild. These vary based on the SCM used. Principle of Least Privilege For illustration purposes, a resource type of \"*\" is used. This should always be narrowed to the specific resource when possible. CodeCommit \u00b6 The codecommit:GitPush IAM permission needs to be added. By default, the associated service role will already have the codecommit:GitPull permission. 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"CodeCommitUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codecommit:GitPush\" ], \"Resource\" : \"*\" } ] } GitHub \u00b6 Permissions are granted through the AWS Connector for GitHub OAuth application from the AWS Console. Buildspec \u00b6 The buildspec can change depending on the base image used by the CodeBuild project. Amazon Images \u00b6 Tested against the Amazon Linux 2, Ubuntu and Windows variants. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # buildspec.yml version : 0.2 env : git-credential-helper : yes # (1) phases : install : commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash pre_build : commands : - git checkout ${CODEBUILD_SOURCE_VERSION##\"refs/heads/\"} # (2) build : commands : - uplift release Without this Uplift will lack any credentials when attempting to push code back to the source SCM. This can be simplified to git checkout $CODEBUILD_SOURCE_VERSION when cloning from GitHub directly Official Uplift Image \u00b6 Tested against the public gembaadvantage/uplift image. Dealing with DockerHub Rate Limits There are known issues with accessing public DockerHub repositories from AWS services, documented here . 1 2 3 4 5 6 7 8 9 10 11 12 # buildspec.yml version : 0.2 env : git-credential-helper : yes phases : pre_build : commands : - git checkout ${CODEBUILD_SOURCE_VERSION##\"refs/heads/\"} build : commands : - uplift release Clone Depth \u00b6 While configuring a CodeBuild project, the clone depth can be specified. For simplicity, a full clone should be used. If a shallow clone is preferred, you may need to fetch all tags by using the --fetch-all flag. A preferred approach for generating an AWS CodePipeline would be to either write a CloudFormation template manually or use the AWS CDK tooling. This is known as Infrastructure as Code (IaC), and wasn't included in the documentation to avoid unnecessary complexity. \u21a9","title":"AWS CodeBuild"},{"location":"ci/awscodebuild/#aws-codebuild","text":"AWS CodeBuild can be used as a standalone service when running Uplift. This guide assumes CodeBuild was configured manually through the AWS Console and focuses on the gotchas 1 . CodeBuild will always receive a git clone with a detached HEAD. By default, Uplift will error in this scenario. When performing a release, this will need to be resolved through a git checkout . The CODEBUILD_SOURCE_VERSION variable contains the necessary git reference.","title":"AWS CodeBuild"},{"location":"ci/awscodebuild/#iam","text":"Additional permissions are needed to pull and push code within AWS CodeBuild. These vary based on the SCM used. Principle of Least Privilege For illustration purposes, a resource type of \"*\" is used. This should always be narrowed to the specific resource when possible.","title":"IAM"},{"location":"ci/awscodebuild/#codecommit","text":"The codecommit:GitPush IAM permission needs to be added. By default, the associated service role will already have the codecommit:GitPull permission. 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"CodeCommitUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codecommit:GitPush\" ], \"Resource\" : \"*\" } ] }","title":"CodeCommit"},{"location":"ci/awscodebuild/#github","text":"Permissions are granted through the AWS Connector for GitHub OAuth application from the AWS Console.","title":"GitHub"},{"location":"ci/awscodebuild/#buildspec","text":"The buildspec can change depending on the base image used by the CodeBuild project.","title":"Buildspec"},{"location":"ci/awscodebuild/#amazon-images","text":"Tested against the Amazon Linux 2, Ubuntu and Windows variants. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # buildspec.yml version : 0.2 env : git-credential-helper : yes # (1) phases : install : commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash pre_build : commands : - git checkout ${CODEBUILD_SOURCE_VERSION##\"refs/heads/\"} # (2) build : commands : - uplift release Without this Uplift will lack any credentials when attempting to push code back to the source SCM. This can be simplified to git checkout $CODEBUILD_SOURCE_VERSION when cloning from GitHub directly","title":"Amazon Images"},{"location":"ci/awscodebuild/#official-uplift-image","text":"Tested against the public gembaadvantage/uplift image. Dealing with DockerHub Rate Limits There are known issues with accessing public DockerHub repositories from AWS services, documented here . 1 2 3 4 5 6 7 8 9 10 11 12 # buildspec.yml version : 0.2 env : git-credential-helper : yes phases : pre_build : commands : - git checkout ${CODEBUILD_SOURCE_VERSION##\"refs/heads/\"} build : commands : - uplift release","title":"Official Uplift Image"},{"location":"ci/awscodebuild/#clone-depth","text":"While configuring a CodeBuild project, the clone depth can be specified. For simplicity, a full clone should be used. If a shallow clone is preferred, you may need to fetch all tags by using the --fetch-all flag. A preferred approach for generating an AWS CodePipeline would be to either write a CloudFormation template manually or use the AWS CDK tooling. This is known as Infrastructure as Code (IaC), and wasn't included in the documentation to avoid unnecessary complexity. \u21a9","title":"Clone Depth"},{"location":"ci/awscodepipeline/","text":"AWS CodePipeline \u00b6 AWS provides two developer services for building code, AWS CodePipeline and AWS CodeBuild . The former being an orchestration tool, while the later executes each stage using a buildspec file. This guide assumes both were configured manually through the AWS Console and only focuses on the gotchas 1 . CodePipeline \u00b6 By default, CodePipeline clones a repository to S3 without the .git metadata folder. A full clone 2 is needed for Uplift to run. CodeBuild \u00b6 CodeBuild will always receive a git clone with a detached HEAD. By default, Uplift will error in this scenario. If performing a release, this will need to be resolved through a git checkout . However, the branch name is not exposed to CodeBuild by default. CodePipeline provides a variable #{SourceVariables.BranchName} that can be mapped to CodeBuild as an environment variable: IAM \u00b6 Additional permissions are needed to pull and push code within AWS CodeBuild. These vary based on the SCM used. Principle of Least Privilege For illustration purposes, a resource type of \"*\" is used. This should always be narrowed to the specific resource when possible. CodeCommit \u00b6 Both the codecommit:GitPull and codecommit:GitPush IAM permissions are needed and should be added to the CodeBuild service role. 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"CodeCommitUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codecommit:GitPull\" , \"codecommit:GitPush\" ], \"Resource\" : \"*\" } ] } GitHub \u00b6 The codestar-connections:UseConnection IAM permission is needed when interacting with GitHub through an AWS CodeStar connection . 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"GitHubUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codestar-connections:UseConnection\" ], \"Resource\" : \"*\" } ] } Buildspec \u00b6 The buildspec will change depending on the CodeBuild project base image. Default Amazon Images \u00b6 Tested against the Amazon Linux 2, Ubuntu and Windows variants. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # buildspec.yml version : 0.2 env : git-credential-helper : yes # (1) phases : install : commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash pre_build : commands : - git checkout $BRANCH_NAME # (2) build : commands : - uplift release Without this Uplift will lack any credentials when attempting to push code back to the source SCM. The BRANCH_NAME environment variable can be referenced directly within the buildspec, once mapped. Official Uplift Image \u00b6 Tested against the public gembaadvantage/uplift image. Dealing with DockerHub Rate Limits There are known issues with accessing public DockerHub repositories from AWS services, documented here . 1 2 3 4 5 6 7 8 9 10 11 12 # buildspec.yml version : 0.2 env : git-credential-helper : yes phases : pre_build : commands : - git checkout $BRANCH_NAME build : commands : - uplift release A preferred approach for generating an AWS CodePipeline would be to either write a CloudFormation template manually or use the AWS CDK tooling. This is known as Infrastructure as Code (IaC), and wasn't included in the documentation to avoid unnecessary complexity. \u21a9 This strategy works for all supported SCM providers. \u21a9","title":"AWS CodePipeline"},{"location":"ci/awscodepipeline/#aws-codepipeline","text":"AWS provides two developer services for building code, AWS CodePipeline and AWS CodeBuild . The former being an orchestration tool, while the later executes each stage using a buildspec file. This guide assumes both were configured manually through the AWS Console and only focuses on the gotchas 1 .","title":"AWS CodePipeline"},{"location":"ci/awscodepipeline/#codepipeline","text":"By default, CodePipeline clones a repository to S3 without the .git metadata folder. A full clone 2 is needed for Uplift to run.","title":"CodePipeline"},{"location":"ci/awscodepipeline/#codebuild","text":"CodeBuild will always receive a git clone with a detached HEAD. By default, Uplift will error in this scenario. If performing a release, this will need to be resolved through a git checkout . However, the branch name is not exposed to CodeBuild by default. CodePipeline provides a variable #{SourceVariables.BranchName} that can be mapped to CodeBuild as an environment variable:","title":"CodeBuild"},{"location":"ci/awscodepipeline/#iam","text":"Additional permissions are needed to pull and push code within AWS CodeBuild. These vary based on the SCM used. Principle of Least Privilege For illustration purposes, a resource type of \"*\" is used. This should always be narrowed to the specific resource when possible.","title":"IAM"},{"location":"ci/awscodepipeline/#codecommit","text":"Both the codecommit:GitPull and codecommit:GitPush IAM permissions are needed and should be added to the CodeBuild service role. 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"CodeCommitUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codecommit:GitPull\" , \"codecommit:GitPush\" ], \"Resource\" : \"*\" } ] }","title":"CodeCommit"},{"location":"ci/awscodepipeline/#github","text":"The codestar-connections:UseConnection IAM permission is needed when interacting with GitHub through an AWS CodeStar connection . 1 2 3 4 5 6 7 8 9 10 11 { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Sid\" : \"GitHubUplift\" , \"Effect\" : \"Allow\" , \"Action\" : [ \"codestar-connections:UseConnection\" ], \"Resource\" : \"*\" } ] }","title":"GitHub"},{"location":"ci/awscodepipeline/#buildspec","text":"The buildspec will change depending on the CodeBuild project base image.","title":"Buildspec"},{"location":"ci/awscodepipeline/#default-amazon-images","text":"Tested against the Amazon Linux 2, Ubuntu and Windows variants. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # buildspec.yml version : 0.2 env : git-credential-helper : yes # (1) phases : install : commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash pre_build : commands : - git checkout $BRANCH_NAME # (2) build : commands : - uplift release Without this Uplift will lack any credentials when attempting to push code back to the source SCM. The BRANCH_NAME environment variable can be referenced directly within the buildspec, once mapped.","title":"Default Amazon Images"},{"location":"ci/awscodepipeline/#official-uplift-image","text":"Tested against the public gembaadvantage/uplift image. Dealing with DockerHub Rate Limits There are known issues with accessing public DockerHub repositories from AWS services, documented here . 1 2 3 4 5 6 7 8 9 10 11 12 # buildspec.yml version : 0.2 env : git-credential-helper : yes phases : pre_build : commands : - git checkout $BRANCH_NAME build : commands : - uplift release A preferred approach for generating an AWS CodePipeline would be to either write a CloudFormation template manually or use the AWS CDK tooling. This is known as Infrastructure as Code (IaC), and wasn't included in the documentation to avoid unnecessary complexity. \u21a9 This strategy works for all supported SCM providers. \u21a9","title":"Official Uplift Image"},{"location":"ci/circleci/","text":"CircleCI \u00b6 An example YAML file for configuring Uplift to run on CircleCI . As Uplift is designed to push changes back to your GitHub repository, you will need to ensure CircleCI is granted write access to your repository. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # .circleci/config.yml version : 2.1 workflows : main : jobs : - release : filters : branches : # Only trigger on the main branch only : main jobs : release : docker : # Can use whatever base image you like - image : cimg/go:1.18 steps : # Configure an SSH key that provides write access to your GitHub repository - add_ssh_keys : fingerprints : - \"3b:c7:44:c9:34:ab:a4:fd:6c:33:4e:a7:7a:97:79:55\" # (1) - checkout # Additional actions specified here - run : curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash - run : uplift release By default, CircleCI will only have read-only access to your repository. For Uplift to work, write access is required. This can be achieved by accessing a repository as a machine-user and then loading its SSH key into the pipeline by its fingerprint","title":"CircleCI"},{"location":"ci/circleci/#circleci","text":"An example YAML file for configuring Uplift to run on CircleCI . As Uplift is designed to push changes back to your GitHub repository, you will need to ensure CircleCI is granted write access to your repository. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # .circleci/config.yml version : 2.1 workflows : main : jobs : - release : filters : branches : # Only trigger on the main branch only : main jobs : release : docker : # Can use whatever base image you like - image : cimg/go:1.18 steps : # Configure an SSH key that provides write access to your GitHub repository - add_ssh_keys : fingerprints : - \"3b:c7:44:c9:34:ab:a4:fd:6c:33:4e:a7:7a:97:79:55\" # (1) - checkout # Additional actions specified here - run : curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash - run : uplift release By default, CircleCI will only have read-only access to your repository. For Uplift to work, write access is required. This can be achieved by accessing a repository as a machine-user and then loading its SSH key into the pipeline by its fingerprint","title":"CircleCI"},{"location":"ci/cirrusci/","text":"Cirrus CI \u00b6 An example YAML file for configuring Uplift to run on Cirrus CI . Access to GitHub is managed through their dedicated GitHub Application . As Uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the public_repo permission and added to Cirrus CI as an encrypted variable . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # .cirrus.yml task : name : Release # Only run on the main branch only_if : $BRANCH == \"main\" && $CIRRUS_TAG == \"\" container : image : gembaadvantage/uplift:latest before_script : - CLONE_URL=${CIRRUS_REPO_CLONE_URL#\"https://\"} - git remote set-url origin \"https://${GITHUB_TOKEN}@${CLONE_URL}\" release_script : - uplift release --fetch-all # (1) environment : GITHUB_TOKEN : ENCRYPTED[!ID!] # (2) As Cirrus CI uses go-git for cloning repositories from GitHub, by default, it doesn't fetch tags. Using the --fetch-all flag with Uplift ensures all tags are pulled before attempting a release !ID! should be replaced with the internal ID generated by Cirrus CI. GITHUB_TOKEN can be replaced with any chosen variable name and must be reflected in the remote URL. environment and env are interchangeable. Uplift publishes docker images that support both amd64 and arm64 architectures, Cirrus CI can be configured to use arm64 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # .cirrus.yml task : name : Release # Only run on the main branch only_if : $BRANCH == \"main\" && $CIRRUS_TAG == \"\" arm_container : image : gembaadvantage/uplift:latest # (1) before_script : - CLONE_URL=${CIRRUS_REPO_CLONE_URL#\"https://\"} - git remote set-url origin \"https://${GITHUB_TOKEN}@${CLONE_URL}\" release_script : - uplift release --fetch-all environment : GITHUB_TOKEN : ENCRYPTED[!ID!] Cirrus CI will seamlessly download the arm64 image from either DockerHub or GHCR through the use of the --platform flag.","title":"Cirrus CI"},{"location":"ci/cirrusci/#cirrus-ci","text":"An example YAML file for configuring Uplift to run on Cirrus CI . Access to GitHub is managed through their dedicated GitHub Application . As Uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the public_repo permission and added to Cirrus CI as an encrypted variable . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # .cirrus.yml task : name : Release # Only run on the main branch only_if : $BRANCH == \"main\" && $CIRRUS_TAG == \"\" container : image : gembaadvantage/uplift:latest before_script : - CLONE_URL=${CIRRUS_REPO_CLONE_URL#\"https://\"} - git remote set-url origin \"https://${GITHUB_TOKEN}@${CLONE_URL}\" release_script : - uplift release --fetch-all # (1) environment : GITHUB_TOKEN : ENCRYPTED[!ID!] # (2) As Cirrus CI uses go-git for cloning repositories from GitHub, by default, it doesn't fetch tags. Using the --fetch-all flag with Uplift ensures all tags are pulled before attempting a release !ID! should be replaced with the internal ID generated by Cirrus CI. GITHUB_TOKEN can be replaced with any chosen variable name and must be reflected in the remote URL. environment and env are interchangeable. Uplift publishes docker images that support both amd64 and arm64 architectures, Cirrus CI can be configured to use arm64 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # .cirrus.yml task : name : Release # Only run on the main branch only_if : $BRANCH == \"main\" && $CIRRUS_TAG == \"\" arm_container : image : gembaadvantage/uplift:latest # (1) before_script : - CLONE_URL=${CIRRUS_REPO_CLONE_URL#\"https://\"} - git remote set-url origin \"https://${GITHUB_TOKEN}@${CLONE_URL}\" release_script : - uplift release --fetch-all environment : GITHUB_TOKEN : ENCRYPTED[!ID!] Cirrus CI will seamlessly download the arm64 image from either DockerHub or GHCR through the use of the --platform flag.","title":"Cirrus CI"},{"location":"ci/codefresh/","text":"Codefresh \u00b6 An example YAML file for configuring Uplift to run on Codefresh . To ensure Uplift can push changes back to your repository, you will need to store your Personal Access Token as a shared configuration and expose it to your pipeline as an environment variable, which in this example is GH_UPLIFT . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # codefresh.yml version : \"1.0\" stages : - prepare - release steps : main_clone : # (1) title : \"Checkout\" type : git-clone repo : \"${{CF_REPO_OWNER}}/${{CF_REPO_NAME}}\" revision : \"${{CF_BRANCH}}\" # (2) stage : prepare uplift : title : \"Release\" stage : release image : \"gembaadvantage/uplift\" commands : - REMOTE_URL=$(git config --get remote.origin.url) - CLONE_URL=${REMOTE_URL#\"https://\"} - git remote set-url origin \"https://${GH_UPLIFT}@${CLONE_URL}\" - uplift release main_clone is a reserved step within Codefresh and is used to simplify the checkout process. A custom checkout can be performed, but you will need to managed the working directory across all other steps. By ensuring the clone is of a specific branch, it prevents the checkout of a detached HEAD.","title":"Codefresh"},{"location":"ci/codefresh/#codefresh","text":"An example YAML file for configuring Uplift to run on Codefresh . To ensure Uplift can push changes back to your repository, you will need to store your Personal Access Token as a shared configuration and expose it to your pipeline as an environment variable, which in this example is GH_UPLIFT . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # codefresh.yml version : \"1.0\" stages : - prepare - release steps : main_clone : # (1) title : \"Checkout\" type : git-clone repo : \"${{CF_REPO_OWNER}}/${{CF_REPO_NAME}}\" revision : \"${{CF_BRANCH}}\" # (2) stage : prepare uplift : title : \"Release\" stage : release image : \"gembaadvantage/uplift\" commands : - REMOTE_URL=$(git config --get remote.origin.url) - CLONE_URL=${REMOTE_URL#\"https://\"} - git remote set-url origin \"https://${GH_UPLIFT}@${CLONE_URL}\" - uplift release main_clone is a reserved step within Codefresh and is used to simplify the checkout process. A custom checkout can be performed, but you will need to managed the working directory across all other steps. By ensuring the clone is of a specific branch, it prevents the checkout of a detached HEAD.","title":"Codefresh"},{"location":"ci/drone/","text":"Drone \u00b6 An example YAML file for configuring Uplift to run on Drone 1 . Instructions for deploying a self-hosted instance of drone can be found here . Uplift requires write permissions to your repository. A Personal Access Token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) needs to be configured with the public_repo permission and added to Drone as an encrypted secret . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # .drone.yml kind : pipeline type : docker name : default steps : - name : set-remote image : docker:git environment : GITHUB_PAT : from_secret : github_pat commands : - CLONE_URL=${DRONE_GIT_HTTP_URL##https://} - git remote set-url origin https://$GITHUB_PAT@$CLONE_URL when : branch : - main event : - push - name : release image : gembaadvantage/uplift commands : - uplift release --fetch-all # (1) when : branch : - main event : - push --- kind : secret name : github_pat data : VLO71Ad3QSALQjELGKg5U7r92823a9e4vmu7xUw3LJ9xKwZu8X... Drone does not retrieve any tags by default. Uplift can retrieve all of the latest tags by providing the --fetch-all flag. Drone still has a self-hosted offering, but its SaaS product is now integrated with Harness CI . \u21a9","title":"Drone"},{"location":"ci/drone/#drone","text":"An example YAML file for configuring Uplift to run on Drone 1 . Instructions for deploying a self-hosted instance of drone can be found here . Uplift requires write permissions to your repository. A Personal Access Token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) needs to be configured with the public_repo permission and added to Drone as an encrypted secret . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # .drone.yml kind : pipeline type : docker name : default steps : - name : set-remote image : docker:git environment : GITHUB_PAT : from_secret : github_pat commands : - CLONE_URL=${DRONE_GIT_HTTP_URL##https://} - git remote set-url origin https://$GITHUB_PAT@$CLONE_URL when : branch : - main event : - push - name : release image : gembaadvantage/uplift commands : - uplift release --fetch-all # (1) when : branch : - main event : - push --- kind : secret name : github_pat data : VLO71Ad3QSALQjELGKg5U7r92823a9e4vmu7xUw3LJ9xKwZu8X... Drone does not retrieve any tags by default. Uplift can retrieve all of the latest tags by providing the --fetch-all flag. Drone still has a self-hosted offering, but its SaaS product is now integrated with Harness CI . \u21a9","title":"Drone"},{"location":"ci/github/","text":"GitHub Action \u00b6 The official GitHub Action can be used to configure Uplift within your workflow. As Uplift is designed to push changes back to your repository, you will need to provide it with an access token 1 . This is by design . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # .github/workflows/ci.yml name : ci on : push : branches : - main pull_request : jobs : ci : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 with : fetch-depth : 0 # (1) # Additional steps specified here - name : Release if : github.ref == 'refs/heads/main' uses : gembaadvantage/uplift-action@v2.0.1 with : args : release env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} # (2) Setting a fetch-depth of 0 will ensure all tags are retrieved, which is required by Uplift to determine the next semantic version When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN will not create a new workflow run. Triggering another Workflow \u00b6 To ensure Uplift triggers another workflow run when tagging the repository, a personal access token should be created and stored as a secret . This will then replace the default GITHUB_TOKEN as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # .github/workflows/ci.yml name : ci on : push : branches : - main pull_request : jobs : ci : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 with : fetch-depth : 0 # Additional steps specified here - name : Release if : github.ref == 'refs/heads/main' uses : gembaadvantage/uplift-action@v2.0.1 with : args : release env : GITHUB_TOKEN : ${{ secrets.GH_UPLIFT }} It is best security practice to create an access token with the shortest possible expiration date. \u21a9","title":"GitHub Action"},{"location":"ci/github/#github-action","text":"The official GitHub Action can be used to configure Uplift within your workflow. As Uplift is designed to push changes back to your repository, you will need to provide it with an access token 1 . This is by design . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # .github/workflows/ci.yml name : ci on : push : branches : - main pull_request : jobs : ci : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 with : fetch-depth : 0 # (1) # Additional steps specified here - name : Release if : github.ref == 'refs/heads/main' uses : gembaadvantage/uplift-action@v2.0.1 with : args : release env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} # (2) Setting a fetch-depth of 0 will ensure all tags are retrieved, which is required by Uplift to determine the next semantic version When you use the repository's GITHUB_TOKEN to perform tasks, events triggered by the GITHUB_TOKEN will not create a new workflow run.","title":"GitHub Action"},{"location":"ci/github/#triggering-another-workflow","text":"To ensure Uplift triggers another workflow run when tagging the repository, a personal access token should be created and stored as a secret . This will then replace the default GITHUB_TOKEN as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # .github/workflows/ci.yml name : ci on : push : branches : - main pull_request : jobs : ci : runs-on : ubuntu-latest steps : - name : Checkout uses : actions/checkout@v3 with : fetch-depth : 0 # Additional steps specified here - name : Release if : github.ref == 'refs/heads/main' uses : gembaadvantage/uplift-action@v2.0.1 with : args : release env : GITHUB_TOKEN : ${{ secrets.GH_UPLIFT }} It is best security practice to create an access token with the shortest possible expiration date. \u21a9","title":"Triggering another Workflow"},{"location":"ci/gitlab/","text":"GitLab \u00b6 An example YAML file for configuring Uplift to run on GitLab . To ensure Uplift can push changes back to your repository, you will need to provide it with a project ](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html) or group access token 1 with the write_repository permission. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # .gitlab-ci.yml stages : - release release : stage : release image : name : gembaadvantage/uplift entrypoint : [ \"\" ] dependencies : [] # (1) before_script : - PROJECT_URL=${CI_PROJECT_URL#\"https://\"} - git remote set-url origin \"https://oauth2:${GL_UPLIFT}@${PROJECT_URL}.git\" variables : # Disable shallow cloning of repository GIT_DEPTH : 0 script : # GitLab by default checks out a detached HEAD - git checkout $CI_COMMIT_REF_NAME - uplift release # Only run on the default branch of the repository rules : - if : '$CI_PIPELINE_SOURCE == \"merge_request_event\"' when : never - if : \"$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\" when : on_success Prevents any dependencies, such as reports, from being unnecessarily copied into this job and causing the git checks to fail To expose your access token within your pipeline you should add a CI/CD variable . In the above example, the access token is exposed through the GL_UPLIFT variable. It is best security practice to create an access token with the shortest possible expiration date. \u21a9","title":"GitLab"},{"location":"ci/gitlab/#gitlab","text":"An example YAML file for configuring Uplift to run on GitLab . To ensure Uplift can push changes back to your repository, you will need to provide it with a project ](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html) or group access token 1 with the write_repository permission. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # .gitlab-ci.yml stages : - release release : stage : release image : name : gembaadvantage/uplift entrypoint : [ \"\" ] dependencies : [] # (1) before_script : - PROJECT_URL=${CI_PROJECT_URL#\"https://\"} - git remote set-url origin \"https://oauth2:${GL_UPLIFT}@${PROJECT_URL}.git\" variables : # Disable shallow cloning of repository GIT_DEPTH : 0 script : # GitLab by default checks out a detached HEAD - git checkout $CI_COMMIT_REF_NAME - uplift release # Only run on the default branch of the repository rules : - if : '$CI_PIPELINE_SOURCE == \"merge_request_event\"' when : never - if : \"$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\" when : on_success Prevents any dependencies, such as reports, from being unnecessarily copied into this job and causing the git checks to fail To expose your access token within your pipeline you should add a CI/CD variable . In the above example, the access token is exposed through the GL_UPLIFT variable. It is best security practice to create an access token with the shortest possible expiration date. \u21a9","title":"GitLab"},{"location":"ci/semaphore/","text":"Semaphore \u00b6 Example YAML files for configuring Uplift to run on Semaphore 2.0 . All Semaphore pipelines start with the default file .semaphore/semaphore.yml within your repository. To ensure Uplift is only executed on the main branch, a separate pipeline YAML file is used, triggered by semaphore promotions . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # .semaphore/semaphore.yml version : v1.0 name : CI Pipeline agent : machine : type : e1-standard-2 os_image : ubuntu2004 blocks : - name : \"CI\" task : jobs : - name : \"Checkout\" commands : - checkout # Additional jobs specified here # Promotions are used to optionally trigger Uplift on any push to the main branch promotions : - name : Uplift pipeline_file : uplift.yml auto_promote_on : - result : passed branch : - main A dedicated pipeline installs Uplift and triggers a release: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # .semaphore/uplift.yml version : \"v1.0\" name : Uplift agent : machine : type : e1-standard-2 os_image : ubuntu2004 blocks : - name : \"Release\" task : prologue : commands : - checkout jobs : - name : uplift commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash - uplift release # (1) By default, Semaphore installs a GitHub application that has write access to a list of preselected repositories. This ensures no additional configuration is needed to grant Uplift permissions for pushing changes back to GitHub","title":"Semaphore"},{"location":"ci/semaphore/#semaphore","text":"Example YAML files for configuring Uplift to run on Semaphore 2.0 . All Semaphore pipelines start with the default file .semaphore/semaphore.yml within your repository. To ensure Uplift is only executed on the main branch, a separate pipeline YAML file is used, triggered by semaphore promotions . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # .semaphore/semaphore.yml version : v1.0 name : CI Pipeline agent : machine : type : e1-standard-2 os_image : ubuntu2004 blocks : - name : \"CI\" task : jobs : - name : \"Checkout\" commands : - checkout # Additional jobs specified here # Promotions are used to optionally trigger Uplift on any push to the main branch promotions : - name : Uplift pipeline_file : uplift.yml auto_promote_on : - result : passed branch : - main A dedicated pipeline installs Uplift and triggers a release: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # .semaphore/uplift.yml version : \"v1.0\" name : Uplift agent : machine : type : e1-standard-2 os_image : ubuntu2004 blocks : - name : \"Release\" task : prologue : commands : - checkout jobs : - name : uplift commands : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash - uplift release # (1) By default, Semaphore installs a GitHub application that has write access to a list of preselected repositories. This ensures no additional configuration is needed to grant Uplift permissions for pushing changes back to GitHub","title":"Semaphore"},{"location":"ci/travisci/","text":"Travis CI \u00b6 An example YAML file for configuring Uplift to run on Travis CI . Access to GitHub is managed through their dedicated GitHub Application . Uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the public_repo permission and added to Travis CI as an encrypted variable . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # .travis.yml # Setup the pipeline based on your chosen language language : go git : depth : false before_install : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash script : - git remote set-url origin https://${GH_UPLIFT}@github.com/${TRAVIS_REPO_SLUG}.git - git checkout $TRAVIS_BRANCH deploy : - provider : script skip_cleanup : true script : uplift release on : branch : main condition : $TRAVIS_OS_NAME = linux # (1) env : global : secure : 0l3pSB3Du+YQuV4Gf0R2PoPlrGnmuQhpEbab4KmgUJu6P4S.... # (2) If you have configured Travis CI to use a build matrix , a condition like this should be used to ensure Uplift is only run once. You will need to download Travis in order to encrypt variables. Once downloaded, you must first login travis --login --pro --github-token=<TRAVIS_TOKEN> and then generate an encrypted variable with a command similar to echo GH_UPLIFT=<PERSONAL_ACCESS_TOKEN> | travis encrypt --add --pro","title":"Travis CI"},{"location":"ci/travisci/#travis-ci","text":"An example YAML file for configuring Uplift to run on Travis CI . Access to GitHub is managed through their dedicated GitHub Application . Uplift requires write permissions to your repository, a Personal Access Token needs to be configured with the public_repo permission and added to Travis CI as an encrypted variable . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # .travis.yml # Setup the pipeline based on your chosen language language : go git : depth : false before_install : - curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash script : - git remote set-url origin https://${GH_UPLIFT}@github.com/${TRAVIS_REPO_SLUG}.git - git checkout $TRAVIS_BRANCH deploy : - provider : script skip_cleanup : true script : uplift release on : branch : main condition : $TRAVIS_OS_NAME = linux # (1) env : global : secure : 0l3pSB3Du+YQuV4Gf0R2PoPlrGnmuQhpEbab4KmgUJu6P4S.... # (2) If you have configured Travis CI to use a build matrix , a condition like this should be used to ensure Uplift is only run once. You will need to download Travis in order to encrypt variables. Once downloaded, you must first login travis --login --pro --github-token=<TRAVIS_TOKEN> and then generate an encrypted variable with a command similar to echo GH_UPLIFT=<PERSONAL_ACCESS_TOKEN> | travis encrypt --add --pro","title":"Travis CI"},{"location":"faq/gitdetached/","text":"Git repository has a detached HEAD \u00b6 File bumping and changelog creation will not run reliably against a git repository cloned at a specific commit rather than a branch, known as a detached HEAD. Some CI providers use this as an efficient cloning strategy, but it prevents Uplift from pushing changes back to the default branch. If detected, Uplift will report the following error: uplift cannot reliably run when the repository is in a detached HEAD state. Some features will not run as expected. To suppress this error, use the ' --ignore-detached ' flag, or set the required config . For further details visit: https://upliftci.dev/faq/gitdetached How to fix it \u00b6 You can resolve this error in one of two ways. Reattach the HEAD of your Repository \u00b6 Resolving a detached HEAD requires you to check out the default branch, effectively reattaching the HEAD. Please look at our documented CI providers for examples of how to do this. Suppress the error \u00b6 You can suppress this error by setting the --ignore-detached flag or by modifying your .uplift.yml config file: 1 2 3 4 # .uplift.yml git : ignoreDetached : true","title":"Git Repository has a Detached HEAD"},{"location":"faq/gitdetached/#git-repository-has-a-detached-head","text":"File bumping and changelog creation will not run reliably against a git repository cloned at a specific commit rather than a branch, known as a detached HEAD. Some CI providers use this as an efficient cloning strategy, but it prevents Uplift from pushing changes back to the default branch. If detected, Uplift will report the following error: uplift cannot reliably run when the repository is in a detached HEAD state. Some features will not run as expected. To suppress this error, use the ' --ignore-detached ' flag, or set the required config . For further details visit: https://upliftci.dev/faq/gitdetached","title":"Git repository has a detached HEAD"},{"location":"faq/gitdetached/#how-to-fix-it","text":"You can resolve this error in one of two ways.","title":"How to fix it"},{"location":"faq/gitdetached/#reattach-the-head-of-your-repository","text":"Resolving a detached HEAD requires you to check out the default branch, effectively reattaching the HEAD. Please look at our documented CI providers for examples of how to do this.","title":"Reattach the HEAD of your Repository"},{"location":"faq/gitdetached/#suppress-the-error","text":"You can suppress this error by setting the --ignore-detached flag or by modifying your .uplift.yml config file: 1 2 3 4 # .uplift.yml git : ignoreDetached : true","title":"Suppress the error"},{"location":"faq/gitdirty/","text":"Git Repository is in a Dirty State \u00b6 Uplift can't run against a git repository with unstaged or uncommitted files, typically known as a dirty state. If detected, Uplift will report the following error: uplift cannot reliably run if the repository is in a dirty state. Changes detected: ?? coverage.out Please check and resolve the status of these files before retrying. For further details visit: https://upliftci.dev/faq/gitdirty How to fix it \u00b6 You can resolve this error in one of two ways. Use a .gitignore file \u00b6 Add or modify an existing .gitignore file to ignore the offending files listed in the error message. Adapt your CI \u00b6 Ensure no tracked files are unexpectedly modified Prevent the creation of temporary files. If this isn't possible, you can fall back to using a .gitignore file.","title":"Git Repository is in a Dirty State"},{"location":"faq/gitdirty/#git-repository-is-in-a-dirty-state","text":"Uplift can't run against a git repository with unstaged or uncommitted files, typically known as a dirty state. If detected, Uplift will report the following error: uplift cannot reliably run if the repository is in a dirty state. Changes detected: ?? coverage.out Please check and resolve the status of these files before retrying. For further details visit: https://upliftci.dev/faq/gitdirty","title":"Git Repository is in a Dirty State"},{"location":"faq/gitdirty/#how-to-fix-it","text":"You can resolve this error in one of two ways.","title":"How to fix it"},{"location":"faq/gitdirty/#use-a-gitignore-file","text":"Add or modify an existing .gitignore file to ignore the offending files listed in the error message.","title":"Use a .gitignore file"},{"location":"faq/gitdirty/#adapt-your-ci","text":"Ensure no tracked files are unexpectedly modified Prevent the creation of temporary files. If this isn't possible, you can fall back to using a .gitignore file.","title":"Adapt your CI"},{"location":"faq/gitshallow/","text":"Git Repository contains a Shallow Clone \u00b6 A git repository from a shallow clone will contain a truncated commit history and potentially no previous tags, disabling most, if not all, of the Uplift features. Cloning behaviour will differ between CI providers. If detected, Uplift will report the following error: uplift cannot reliably run against a shallow clone of the repository. Some features may not work as expected. To suppress this error, use the ' --ignore-shallow ' flag, or set the required config . For further details visit: https://upliftci.dev/faq/gitshallow How to fix it \u00b6 You can resolve this error in one of three ways. Fetch the history \u00b6 If no history exists, use the -- flag... Fetch the tags \u00b6 If no tags exist, use the --fetch-tags flag to fetch all tags from the origin. Suppress the error \u00b6 You can suppress this error by setting the --ignore-shallow flag or by modifying your .uplift.yml config file: 1 2 3 4 # .uplift.yml git : ignoreShallow : true","title":"Git Repository contains a Shallow Clone"},{"location":"faq/gitshallow/#git-repository-contains-a-shallow-clone","text":"A git repository from a shallow clone will contain a truncated commit history and potentially no previous tags, disabling most, if not all, of the Uplift features. Cloning behaviour will differ between CI providers. If detected, Uplift will report the following error: uplift cannot reliably run against a shallow clone of the repository. Some features may not work as expected. To suppress this error, use the ' --ignore-shallow ' flag, or set the required config . For further details visit: https://upliftci.dev/faq/gitshallow","title":"Git Repository contains a Shallow Clone"},{"location":"faq/gitshallow/#how-to-fix-it","text":"You can resolve this error in one of three ways.","title":"How to fix it"},{"location":"faq/gitshallow/#fetch-the-history","text":"If no history exists, use the -- flag...","title":"Fetch the history"},{"location":"faq/gitshallow/#fetch-the-tags","text":"If no tags exist, use the --fetch-tags flag to fetch all tags from the origin.","title":"Fetch the tags"},{"location":"faq/gitshallow/#suppress-the-error","text":"You can suppress this error by setting the --ignore-shallow flag or by modifying your .uplift.yml config file: 1 2 3 4 # .uplift.yml git : ignoreShallow : true","title":"Suppress the error"},{"location":"faq/gpgimport/","text":"GPG Key fails to Import \u00b6 Uplift supports the signing of commits by importing a GPG key and correctly configuring git. Your GPG key needs to be exported in the ASCII Armor Format ( optionally base64 encoded ) for this to work. Uplift will report the following error: uplift could not import GPG key with fingerprint FDA7347ACCE12A6CEBED57727B0EDBE188EE9114. Check your GPG key was exported correctly. For further details visit: https://upliftci.dev/faq/gpgimport How to fix it \u00b6 You can resolve this error by exporting your key using the --armor flag. Please read the following guide on how to do this.","title":"GPG Key fails to Import"},{"location":"faq/gpgimport/#gpg-key-fails-to-import","text":"Uplift supports the signing of commits by importing a GPG key and correctly configuring git. Your GPG key needs to be exported in the ASCII Armor Format ( optionally base64 encoded ) for this to work. Uplift will report the following error: uplift could not import GPG key with fingerprint FDA7347ACCE12A6CEBED57727B0EDBE188EE9114. Check your GPG key was exported correctly. For further details visit: https://upliftci.dev/faq/gpgimport","title":"GPG Key fails to Import"},{"location":"faq/gpgimport/#how-to-fix-it","text":"You can resolve this error by exporting your key using the --armor flag. Please read the following guide on how to do this.","title":"How to fix it"},{"location":"install/binary/","text":"Installing the Binary \u00b6 You can use various package managers to install the Uplift binary. Take your pick. Package Managers \u00b6 Homebrew \u00b6 To use Homebrew : brew install gembaadvantage/tap/uplift Scoop \u00b6 To use Scoop : scoop install uplift Apt \u00b6 To install using the apt package manager: echo 'deb [trusted=yes] https://fury.upliftci.dev/apt/ /' | sudo tee /etc/apt/sources.list.d/uplift.list sudo apt update sudo apt install -y uplift You may need to install the ca-certificates package if you encounter trust issues with regards to the Gemfury certificate: sudo apt update && sudo apt install -y ca-certificates Yum \u00b6 To install using the yum package manager: echo '[uplift] name=uplift baseurl=https://fury.upliftci.dev/yum/ enabled=1 gpgcheck=0' | sudo tee /etc/yum.repos.d/uplift.repo sudo yum install -y uplift Aur \u00b6 To install from the aur using yay : yay -S uplift-bin Linux Packages \u00b6 Download and manually install one of the .deb , .rpm or .apk packages from the Releases page. Apt Yum Apk sudo apt install uplift_*.deb sudo yum localinstall uplift_*.rpm sudo apk add --no-cache --allow-untrusted uplift_*.apk Bash Script \u00b6 To install the latest version using a bash script: curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash Download a specific version using the -v flag. The script uses sudo by default but can be disabled through the --no-sudo flag. curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash -s -- -v v2.6.3 --no-sudo Manual Download of Binary \u00b6 Binary downloads of uplift can be found on the Releases page. Unpack the uplift binary and add it to your PATH . Verifying a Binary with Cosign \u00b6 All binaries can be verified using cosign . Download the checksum files that need to be verified: curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt -O curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt.sig -O curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt.pem -O Verify the signature of the checksum file: cosign verify-blob --cert checksums.txt.pem --signature checksums.txt.sig checksums.txt Download any release artefact and verify its SHA256 signature matches the entry within the checksum file: sha256sum --ignore-missing -c checksums.txt","title":"Binary"},{"location":"install/binary/#installing-the-binary","text":"You can use various package managers to install the Uplift binary. Take your pick.","title":"Installing the Binary"},{"location":"install/binary/#package-managers","text":"","title":"Package Managers"},{"location":"install/binary/#homebrew","text":"To use Homebrew : brew install gembaadvantage/tap/uplift","title":"Homebrew"},{"location":"install/binary/#scoop","text":"To use Scoop : scoop install uplift","title":"Scoop"},{"location":"install/binary/#apt","text":"To install using the apt package manager: echo 'deb [trusted=yes] https://fury.upliftci.dev/apt/ /' | sudo tee /etc/apt/sources.list.d/uplift.list sudo apt update sudo apt install -y uplift You may need to install the ca-certificates package if you encounter trust issues with regards to the Gemfury certificate: sudo apt update && sudo apt install -y ca-certificates","title":"Apt"},{"location":"install/binary/#yum","text":"To install using the yum package manager: echo '[uplift] name=uplift baseurl=https://fury.upliftci.dev/yum/ enabled=1 gpgcheck=0' | sudo tee /etc/yum.repos.d/uplift.repo sudo yum install -y uplift","title":"Yum"},{"location":"install/binary/#aur","text":"To install from the aur using yay : yay -S uplift-bin","title":"Aur"},{"location":"install/binary/#linux-packages","text":"Download and manually install one of the .deb , .rpm or .apk packages from the Releases page. Apt Yum Apk sudo apt install uplift_*.deb sudo yum localinstall uplift_*.rpm sudo apk add --no-cache --allow-untrusted uplift_*.apk","title":"Linux Packages"},{"location":"install/binary/#bash-script","text":"To install the latest version using a bash script: curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash Download a specific version using the -v flag. The script uses sudo by default but can be disabled through the --no-sudo flag. curl https://raw.githubusercontent.com/gembaadvantage/uplift/main/scripts/install | bash -s -- -v v2.6.3 --no-sudo","title":"Bash Script"},{"location":"install/binary/#manual-download-of-binary","text":"Binary downloads of uplift can be found on the Releases page. Unpack the uplift binary and add it to your PATH .","title":"Manual Download of Binary"},{"location":"install/binary/#verifying-a-binary-with-cosign","text":"All binaries can be verified using cosign . Download the checksum files that need to be verified: curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt -O curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt.sig -O curl -sL https://github.com/gembaadvantage/uplift/releases/download/v2.5.0/checksums.txt.pem -O Verify the signature of the checksum file: cosign verify-blob --cert checksums.txt.pem --signature checksums.txt.sig checksums.txt Download any release artefact and verify its SHA256 signature matches the entry within the checksum file: sha256sum --ignore-missing -c checksums.txt","title":"Verifying a Binary with Cosign"},{"location":"install/docker/","text":"Running with Docker \u00b6 You can run Uplift directly from a docker image. Just mount your repository as a volume and set it as the working directory. \ud83d\udc33 DockerHub GHCR docker run --rm -v $PWD :/tmp -w /tmp gembaadvantage/uplift release docker run --rm -v $PWD :/tmp -w /tmp ghcr.io/gembaadvantage/uplift release Verifying with Cosign \u00b6 Docker images can be verified using cosign . DockerHub GHCR COSIGN_EXPERIMENTAL = 1 cosign verify gembaadvantage/uplift COSIGN_EXPERIMENTAL = 1 cosign verify ghcr.io/gembaadvantage/uplift","title":"With Docker"},{"location":"install/docker/#running-with-docker","text":"You can run Uplift directly from a docker image. Just mount your repository as a volume and set it as the working directory. \ud83d\udc33 DockerHub GHCR docker run --rm -v $PWD :/tmp -w /tmp gembaadvantage/uplift release docker run --rm -v $PWD :/tmp -w /tmp ghcr.io/gembaadvantage/uplift release","title":"Running with Docker"},{"location":"install/docker/#verifying-with-cosign","text":"Docker images can be verified using cosign . DockerHub GHCR COSIGN_EXPERIMENTAL = 1 cosign verify gembaadvantage/uplift COSIGN_EXPERIMENTAL = 1 cosign verify ghcr.io/gembaadvantage/uplift","title":"Verifying with Cosign"},{"location":"install/oh-my-zsh/","text":"Install the Oh My Zsh Plugin \u00b6 Get all the extra autocompletion goodness with Oh My Zsh. git clone https://github.com/gembaadvantage/uplift-oh-my-zsh ~/.oh-my-zsh/plugins/uplift Enable it within your ~/.zshrc file: plugins =( ... uplift ) Fin!","title":"Oh My Zsh"},{"location":"install/oh-my-zsh/#install-the-oh-my-zsh-plugin","text":"Get all the extra autocompletion goodness with Oh My Zsh. git clone https://github.com/gembaadvantage/uplift-oh-my-zsh ~/.oh-my-zsh/plugins/uplift Enable it within your ~/.zshrc file: plugins =( ... uplift ) Fin!","title":"Install the Oh My Zsh Plugin"},{"location":"install/source/","text":"Compiling from Source \u00b6 Download both Go 1.19+ and go-task . Then clone the code from GitHub: git clone https://github.com/gembaadvantage/uplift.git cd uplift Build: task And check that everything works: ./uplift version","title":"From Source"},{"location":"install/source/#compiling-from-source","text":"Download both Go 1.19+ and go-task . Then clone the code from GitHub: git clone https://github.com/gembaadvantage/uplift.git cd uplift Build: task And check that everything works: ./uplift version","title":"Compiling from Source"},{"location":"reference/config/","text":"Uplift Configuration \u00b6 You are free to control Uplift through the use of a dedicated configuration file. A variety of different naming conventions are supported: .uplift.yml .uplift.yaml uplift.yml uplift.yaml env \u00b6 1 2 3 4 5 6 7 8 # Define a set of environment variables that are made available to all # hooks. Supports loading environment variables from DotEnv (.env) # files. Environment variables are merged with system wide ones. env : - VARIABLE=VALUE - ANOTHER_VARIABLE=ANOTHER VALUE - .env - path/to/other.env hooks \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # All hooks default to an empty list and will be skipped hooks : # A list of shell commands or scripts to execute before Uplift runs # any tasks within any workflow before : - cargo fetch - ENV=VALUE ./my-custom-script.sh - bash path//to//my-custom-script.sh # (1) # A list of shell commands or scripts to execute before Uplift bumps # any configured file beforeBump : - echo \"Before Bump\" # A list of shell commands or scripts to execute before Uplift runs # its changelog generation task beforeChangelog : - echo \"Before Changelog\" # A list of shell commands or scripts to execute before Uplift tags # the repository with the next semantic release beforeTag : - echo \"Before Tag\" # A list of shell commands or scripts to execute after Uplift # completes all tasks within any workflow after : - echo \"After Workflow\" # A list of shell commands or scripts to execute after Uplift bumps # any configured file afterBump : - echo \"After Bump\" # A list of shell commands or scripts to execute after Uplift generates # a new changelog afterChangelog : - echo \"After Changelog\" # A list of shell commands or scripts to execute after Uplift tags # the repository with the next semantic release afterTag : - echo \"After Tag\" An example of using POSIX based windows commands through the mvdan/sh GitHub library. Pay special attention to the use of // when specifying a path commitAuthor \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Changes the commit author used by Uplift when committing any staged # changes. # # Defaults to the Uplift Bot: uplift-bot <uplift@gembaadvantage.com> commitAuthor : # Name of the author # # Defaults to the author name within the last commit name : \"joe.bloggs\" # Email of the author # # Defaults to the author email within the last commit email : \"joe.bloggs@gmail.com\" commitMessage \u00b6 1 2 3 4 5 # Changes the default commit message used by Uplift when committing # any staged changes. # # Default commit message is: ci(uplift): uplifted for version v0.1.0 commitMessage : \"chore(release): this is a custom release message\" annotatedTags \u00b6 1 2 3 4 5 6 7 8 # Use annotated tags instead of lightweight tags when tagging a new # semantic version. An annotated tag is treated like a regular commit # by git and contains both author details and a commit message. Uplift # will either use its defaults or the custom commit details provided # when generated the annotated tag. # # Defaults to false annotatedTags : true git \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Customise how Uplift responds to its inbuilt Git checks git : # A flag for suppressing the git detached HEAD repository check. If set # to true, Uplift will report a warning while running, otherwise Uplift # will raise an error and stop. # # Defaults to false ignoreDetached : true # A flag for suppressing the git shallow repository check. If set to # true, Uplift will report a warning while running, otherwise Uplift # will raise an error and stop. # # Defaults to false ignoreShallow : true changelog \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Customise the creation of the Changelog changelog : # Change the sort order of the commits within each changelog entry. # Supported values are asc or desc (case is ignored) # # Defaults to desc (descending order) to mirror the default behaviour # of \"git log\" sort : asc # A list of commits to exclude during the creation of a changelog. # Provide a list of conventional commit prefixes to filter on. # Auto-generated commits from Uplift (with the prefix ci(uplift)) will # always be excluded # # Defaults to including all commits within the generated changelog exclude : - chore(deps) - docs - ci bumps \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Define a series of files whose semantic version will be bumped. # Supports both Regex and JSON Path based file bumps # # Defaults to no files being bumped bumps : # The path of the file relative to where Uplift is executed - file : package.json # A JSON path matcher should be used when bumping the file. Multiple # path matches are supported. Each will be carried out in the order # they are defined here. All matches must succeed for the file to # be bumped. JSON path syntax is based on # https://github.com/tidwall/sjson # # Defaults to no matchers json : # A JSON path that will be used for matching the version that # will be replaced within the file - path : \"version\" # If the matched version in the file should be replaced with a # semantic version. This will strip any 'v' prefix if needed # # Defaults to false semver : true # The path of the file relative to where Uplift is executed - file : chart/my-chart/Chart.yaml # A regex matcher should be used when bumping the file. Multiple # regex matches are supported. Each will be carried out in the order # they are defined here. All matches must succeed for the file to # be bumped # # Defaults to no matchers regex : # The regex that should be used for matching the version that # will be replaced within the file - pattern : \"version: $VERSION\" # If the matched version in the file should be replaced with a # semantic version. This will strip any 'v' prefix if needed # # Defaults to false semver : true # The number of times any matched version should be replaced # # Defaults to 0, which replaces all matches count : 1 gitea \u00b6 1 2 3 4 5 6 7 8 # Add support for Gitea SCM detection gitea : # The URL of the self-hosted instance of Gitea. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitea.com github \u00b6 1 2 3 4 5 6 7 8 # Add support for GitHub SCM detection github : # The URL of the enterprise instance of GitHub. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.github.com gitlab \u00b6 1 2 3 4 5 6 7 8 # Add support for GitLab SCM detection gitlab : # The URL of the self-managed instance of GitLab. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitlab.com","title":"Configuration"},{"location":"reference/config/#uplift-configuration","text":"You are free to control Uplift through the use of a dedicated configuration file. A variety of different naming conventions are supported: .uplift.yml .uplift.yaml uplift.yml uplift.yaml","title":"Uplift Configuration"},{"location":"reference/config/#env","text":"1 2 3 4 5 6 7 8 # Define a set of environment variables that are made available to all # hooks. Supports loading environment variables from DotEnv (.env) # files. Environment variables are merged with system wide ones. env : - VARIABLE=VALUE - ANOTHER_VARIABLE=ANOTHER VALUE - .env - path/to/other.env","title":"env"},{"location":"reference/config/#hooks","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # All hooks default to an empty list and will be skipped hooks : # A list of shell commands or scripts to execute before Uplift runs # any tasks within any workflow before : - cargo fetch - ENV=VALUE ./my-custom-script.sh - bash path//to//my-custom-script.sh # (1) # A list of shell commands or scripts to execute before Uplift bumps # any configured file beforeBump : - echo \"Before Bump\" # A list of shell commands or scripts to execute before Uplift runs # its changelog generation task beforeChangelog : - echo \"Before Changelog\" # A list of shell commands or scripts to execute before Uplift tags # the repository with the next semantic release beforeTag : - echo \"Before Tag\" # A list of shell commands or scripts to execute after Uplift # completes all tasks within any workflow after : - echo \"After Workflow\" # A list of shell commands or scripts to execute after Uplift bumps # any configured file afterBump : - echo \"After Bump\" # A list of shell commands or scripts to execute after Uplift generates # a new changelog afterChangelog : - echo \"After Changelog\" # A list of shell commands or scripts to execute after Uplift tags # the repository with the next semantic release afterTag : - echo \"After Tag\" An example of using POSIX based windows commands through the mvdan/sh GitHub library. Pay special attention to the use of // when specifying a path","title":"hooks"},{"location":"reference/config/#commitauthor","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Changes the commit author used by Uplift when committing any staged # changes. # # Defaults to the Uplift Bot: uplift-bot <uplift@gembaadvantage.com> commitAuthor : # Name of the author # # Defaults to the author name within the last commit name : \"joe.bloggs\" # Email of the author # # Defaults to the author email within the last commit email : \"joe.bloggs@gmail.com\"","title":"commitAuthor"},{"location":"reference/config/#commitmessage","text":"1 2 3 4 5 # Changes the default commit message used by Uplift when committing # any staged changes. # # Default commit message is: ci(uplift): uplifted for version v0.1.0 commitMessage : \"chore(release): this is a custom release message\"","title":"commitMessage"},{"location":"reference/config/#annotatedtags","text":"1 2 3 4 5 6 7 8 # Use annotated tags instead of lightweight tags when tagging a new # semantic version. An annotated tag is treated like a regular commit # by git and contains both author details and a commit message. Uplift # will either use its defaults or the custom commit details provided # when generated the annotated tag. # # Defaults to false annotatedTags : true","title":"annotatedTags"},{"location":"reference/config/#git","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Customise how Uplift responds to its inbuilt Git checks git : # A flag for suppressing the git detached HEAD repository check. If set # to true, Uplift will report a warning while running, otherwise Uplift # will raise an error and stop. # # Defaults to false ignoreDetached : true # A flag for suppressing the git shallow repository check. If set to # true, Uplift will report a warning while running, otherwise Uplift # will raise an error and stop. # # Defaults to false ignoreShallow : true","title":"git"},{"location":"reference/config/#changelog","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Customise the creation of the Changelog changelog : # Change the sort order of the commits within each changelog entry. # Supported values are asc or desc (case is ignored) # # Defaults to desc (descending order) to mirror the default behaviour # of \"git log\" sort : asc # A list of commits to exclude during the creation of a changelog. # Provide a list of conventional commit prefixes to filter on. # Auto-generated commits from Uplift (with the prefix ci(uplift)) will # always be excluded # # Defaults to including all commits within the generated changelog exclude : - chore(deps) - docs - ci","title":"changelog"},{"location":"reference/config/#bumps","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Define a series of files whose semantic version will be bumped. # Supports both Regex and JSON Path based file bumps # # Defaults to no files being bumped bumps : # The path of the file relative to where Uplift is executed - file : package.json # A JSON path matcher should be used when bumping the file. Multiple # path matches are supported. Each will be carried out in the order # they are defined here. All matches must succeed for the file to # be bumped. JSON path syntax is based on # https://github.com/tidwall/sjson # # Defaults to no matchers json : # A JSON path that will be used for matching the version that # will be replaced within the file - path : \"version\" # If the matched version in the file should be replaced with a # semantic version. This will strip any 'v' prefix if needed # # Defaults to false semver : true # The path of the file relative to where Uplift is executed - file : chart/my-chart/Chart.yaml # A regex matcher should be used when bumping the file. Multiple # regex matches are supported. Each will be carried out in the order # they are defined here. All matches must succeed for the file to # be bumped # # Defaults to no matchers regex : # The regex that should be used for matching the version that # will be replaced within the file - pattern : \"version: $VERSION\" # If the matched version in the file should be replaced with a # semantic version. This will strip any 'v' prefix if needed # # Defaults to false semver : true # The number of times any matched version should be replaced # # Defaults to 0, which replaces all matches count : 1","title":"bumps"},{"location":"reference/config/#gitea","text":"1 2 3 4 5 6 7 8 # Add support for Gitea SCM detection gitea : # The URL of the self-hosted instance of Gitea. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitea.com","title":"gitea"},{"location":"reference/config/#github","text":"1 2 3 4 5 6 7 8 # Add support for GitHub SCM detection github : # The URL of the enterprise instance of GitHub. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.github.com","title":"github"},{"location":"reference/config/#gitlab","text":"1 2 3 4 5 6 7 8 # Add support for GitLab SCM detection gitlab : # The URL of the self-managed instance of GitLab. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitlab.com","title":"gitlab"},{"location":"reference/cli/bump/","text":"Command Line \u00b6 Bumps the semantic version within files in your git repository. The version bump is based on the conventional commit message from the last commit. Uplift can bump the version in any file using regex pattern matching Usage \u00b6 uplift bump [flags] Flags \u00b6 -h, --help help for bump --prerelease string append a prerelease suffix to next calculated semantic version Global Flags \u00b6 --config-dir string a custom path to a directory containing uplift config (default \".\") --debug show me everything that happens --dry-run run without making any changes --ignore-detached ignore reported git detached HEAD error --ignore-shallow ignore reported git shallow clone error --no-push no changes will be pushed to the git remote --silent silence all logging","title":"uplift bump"},{"location":"reference/cli/bump/#command-line","text":"Bumps the semantic version within files in your git repository. The version bump is based on the conventional commit message from the last commit. Uplift can bump the version in any file using regex pattern matching","title":"Command Line"},{"location":"reference/cli/bump/#usage","text":"uplift bump [flags]","title":"Usage"},{"location":"reference/cli/bump/#flags","text":"-h, --help help for bump --prerelease string append a prerelease suffix to next calculated semantic version","title":"Flags"},{"location":"reference/cli/bump/#global-flags","text":"--config-dir string a custom path to a directory containing uplift config (default \".\") --debug show me everything that happens --dry-run run without making any changes --ignore-detached ignore reported git detached HEAD error --ignore-shallow ignore reported git shallow clone error --no-push no changes will be pushed to the git remote --silent silence all logging","title":"Global Flags"},{"location":"reference/cli/changelog/","text":"Command Line \u00b6 Create or update an existing changelog with an entry for the latest semantic release. For a first release, all commits between the latest tag and trunk will be written to the changelog. Subsequent entries will contain only commits between release tags. Usage \u00b6 uplift changelog [flags] Flags \u00b6 --all generate a changelog from the entire history of this repository --diff-only output the changelog diff only --exclude strings a list of conventional commit prefixes to exclude -h, --help help for changelog --sort string the sort order of commits within each changelog entry Global Flags \u00b6 --config-dir string a custom path to a directory containing uplift config (default \".\") --debug show me everything that happens --dry-run run without making any changes --ignore-detached ignore reported git detached HEAD error --ignore-shallow ignore reported git shallow clone error --no-push no changes will be pushed to the git remote --silent silence all logging","title":"uplift changelog"},{"location":"reference/cli/changelog/#command-line","text":"Create or update an existing changelog with an entry for the latest semantic release. For a first release, all commits between the latest tag and trunk will be written to the changelog. Subsequent entries will contain only commits between release tags.","title":"Command Line"},{"location":"reference/cli/changelog/#usage","text":"uplift changelog [flags]","title":"Usage"},{"location":"reference/cli/changelog/#flags","text":"--all generate a changelog from the entire history of this repository --diff-only output the changelog diff only --exclude strings a list of conventional commit prefixes to exclude -h, --help help for changelog --sort string the sort order of commits within each changelog entry","title":"Flags"},{"location":"reference/cli/changelog/#global-flags","text":"--config-dir string a custom path to a directory containing uplift config (default \".\") --debug show me everything that happens --dry-run run without making any changes --ignore-detached ignore reported git detached HEAD error --ignore-shallow ignore reported git shallow clone error --no-push no changes will be pushed to the git remote --silent silence all logging","title":"Global Flags"},{"location":"reference/cli/release/","text":"Command Line \u00b6 Release the next semantic version of your git repository. A release will automatically bump any files and tag the associated commit with the required semantic version Usage \u00b6 uplift release [flags] Flags \u00b6 --check check if a release will be triggered --exclude strings a list of conventional commit prefixes to exclude from the changelog --fetch-all fetch all tags from the remote repository -h, --help help for release --no-prefix strip the default 'v' prefix from the next calculated semantic version --prerelease string append a prerelease suffix to next calculated semantic version --skip-bumps skips the bumping of any files --skip-changelog skips the creation or amendment of a changelog --sort string the sort order of commits within each changelog entry Global Flags \u00b6 --config-dir string a custom path to a directory containing uplift config (default \".\") --debug show me everything that happens --dry-run run without making any changes --ignore-detached ignore reported git detached HEAD error --ignore-shallow ignore reported git shallow clone error --no-push no changes will be pushed to the git remote --silent silence all logging","title":"uplift release"},{"location":"reference/cli/release/#command-line","text":"Release the next semantic version of your git repository. A release will automatically bump any files and tag the associated commit with the required semantic version","title":"Command Line"},{"location":"reference/cli/release/#usage","text":"uplift release [flags]","title":"Usage"},{"location":"reference/cli/release/#flags","text":"--check check if a release will be triggered --exclude strings a list of conventional commit prefixes to exclude from the changelog --fetch-all fetch all tags from the remote repository -h, --help help for release --no-prefix strip the default 'v' prefix from the next calculated semantic version --prerelease string append a prerelease suffix to next calculated semantic version --skip-bumps skips the bumping of any files --skip-changelog skips the creation or amendment of a changelog --sort string the sort order of commits within each changelog entry","title":"Flags"},{"location":"reference/cli/release/#global-flags","text":"--config-dir string a custom path to a directory containing uplift config (default \".\") --debug show me everything that happens --dry-run run without making any changes --ignore-detached ignore reported git detached HEAD error --ignore-shallow ignore reported git shallow clone error --no-push no changes will be pushed to the git remote --silent silence all logging","title":"Global Flags"},{"location":"reference/cli/root/","text":"Command Line \u00b6 Semantic versioning the easy way. Usage \u00b6 uplift [command] Flags \u00b6 --config-dir string a custom path to a directory containing uplift config (default \".\") --debug show me everything that happens --dry-run run without making any changes -h, --help help for uplift --ignore-detached ignore reported git detached HEAD error --ignore-shallow ignore reported git shallow clone error --no-push no changes will be pushed to the git remote --silent silence all logging Commands \u00b6 bump Bump the semantic version within files changelog Create or update a changelog with the latest semantic release completion Generate completion script for your target shell help Help about any command release Release the next semantic version of a repository tag Tag a git repository with the next semantic version version Prints the build time version information","title":"uplift"},{"location":"reference/cli/root/#command-line","text":"Semantic versioning the easy way.","title":"Command Line"},{"location":"reference/cli/root/#usage","text":"uplift [command]","title":"Usage"},{"location":"reference/cli/root/#flags","text":"--config-dir string a custom path to a directory containing uplift config (default \".\") --debug show me everything that happens --dry-run run without making any changes -h, --help help for uplift --ignore-detached ignore reported git detached HEAD error --ignore-shallow ignore reported git shallow clone error --no-push no changes will be pushed to the git remote --silent silence all logging","title":"Flags"},{"location":"reference/cli/root/#commands","text":"bump Bump the semantic version within files changelog Create or update a changelog with the latest semantic release completion Generate completion script for your target shell help Help about any command release Release the next semantic version of a repository tag Tag a git repository with the next semantic version version Prints the build time version information","title":"Commands"},{"location":"reference/cli/tag/","text":"Command Line \u00b6 Tags a git repository with the next semantic version. The next tag is calculated using the conventional commit message from the last commit. Usage \u00b6 uplift tag [flags] Flags \u00b6 --fetch-all fetch all tags from the remote repository -h, --help help for tag --next output the next tag only --no-prefix strip the default 'v' prefix from the next calculated semantic version --prerelease string append a prerelease suffix to next calculated semantic version Global Flags \u00b6 --config-dir string a custom path to a directory containing uplift config (default \".\") --debug show me everything that happens --dry-run run without making any changes --ignore-detached ignore reported git detached HEAD error --ignore-shallow ignore reported git shallow clone error --no-push no changes will be pushed to the git remote --silent silence all logging","title":"uplift tag"},{"location":"reference/cli/tag/#command-line","text":"Tags a git repository with the next semantic version. The next tag is calculated using the conventional commit message from the last commit.","title":"Command Line"},{"location":"reference/cli/tag/#usage","text":"uplift tag [flags]","title":"Usage"},{"location":"reference/cli/tag/#flags","text":"--fetch-all fetch all tags from the remote repository -h, --help help for tag --next output the next tag only --no-prefix strip the default 'v' prefix from the next calculated semantic version --prerelease string append a prerelease suffix to next calculated semantic version","title":"Flags"},{"location":"reference/cli/tag/#global-flags","text":"--config-dir string a custom path to a directory containing uplift config (default \".\") --debug show me everything that happens --dry-run run without making any changes --ignore-detached ignore reported git detached HEAD error --ignore-shallow ignore reported git shallow clone error --no-push no changes will be pushed to the git remote --silent silence all logging","title":"Global Flags"},{"location":"scm/about/","text":"SCM Detection \u00b6 Experimental Uplift uses SCM ( source code management ) detection to identify repositories from GitHub, GitLab, CodeCommit and Gitea ( pronounced git-tea ). From this detection, Uplift provides the following features: Dynamic links within changelogs Keep an eye on this space More features will be added as Uplift dives more into this space","title":"About"},{"location":"scm/about/#scm-detection","text":"Experimental Uplift uses SCM ( source code management ) detection to identify repositories from GitHub, GitLab, CodeCommit and Gitea ( pronounced git-tea ). From this detection, Uplift provides the following features: Dynamic links within changelogs Keep an eye on this space More features will be added as Uplift dives more into this space","title":"SCM Detection"},{"location":"scm/gitea/","text":"Gitea \u00b6 As Gitea is a self-hosted SCM, custom configuration is required to support detection. 1 2 3 4 5 6 7 8 9 10 # uplift.yml # Add support for Gitea SCM detection gitea : # The URL of the self-hosted instance of Gitea. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitea.com","title":"Gitea"},{"location":"scm/gitea/#gitea","text":"As Gitea is a self-hosted SCM, custom configuration is required to support detection. 1 2 3 4 5 6 7 8 9 10 # uplift.yml # Add support for Gitea SCM detection gitea : # The URL of the self-hosted instance of Gitea. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitea.com","title":"Gitea"},{"location":"scm/github/","text":"GitHub \u00b6 Uplift comes with built-in detection for GitHub (SaaS). However, when using GitHub Enterprise , custom configuration is needed. 1 2 3 4 5 6 7 8 9 10 # uplift.yml # Add support for GitHub SCM detection github : # The URL of the enterprise instance of GitHub. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.github.com","title":"GitHub"},{"location":"scm/github/#github","text":"Uplift comes with built-in detection for GitHub (SaaS). However, when using GitHub Enterprise , custom configuration is needed. 1 2 3 4 5 6 7 8 9 10 # uplift.yml # Add support for GitHub SCM detection github : # The URL of the enterprise instance of GitHub. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.github.com","title":"GitHub"},{"location":"scm/gitlab/","text":"GitLab \u00b6 Uplift comes with built-in detection for GitLab (SaaS). However, when using Self-Managed GitLab , custom configuration is needed. 1 2 3 4 5 6 7 8 9 10 # uplift.yml # Add support for GitLab SCM detection gitlab : # The URL of the self-managed instance of GitLab. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitlab.com","title":"GitLab"},{"location":"scm/gitlab/#gitlab","text":"Uplift comes with built-in detection for GitLab (SaaS). However, when using Self-Managed GitLab , custom configuration is needed. 1 2 3 4 5 6 7 8 9 10 # uplift.yml # Add support for GitLab SCM detection gitlab : # The URL of the self-managed instance of GitLab. Only the scheme and # hostname are required. The hostname is used when matching against # the configured remote origin of the cloned repository # # Defaults to empty string i.e. no detection is supported url : https://my.gitlab.com","title":"GitLab"},{"location":"setup/commit-details/","text":"Changing the Commit Details \u00b6 If you don't want to use the default commit from the Uplift-Bot, you are free to replace both the author and commit message with anything you like: 1 2 3 4 5 commitAuthor : name : \"joe.bloggs\" email : \"joe.bloggs@gmail.com\" commitMessage : \"chore(release): a custom release message\" Uplift uses your GPG Identity If you have imported a GPG key, Uplift will always use the keys user identity over any other configuration","title":"Changing the Commit Details"},{"location":"setup/commit-details/#changing-the-commit-details","text":"If you don't want to use the default commit from the Uplift-Bot, you are free to replace both the author and commit message with anything you like: 1 2 3 4 5 commitAuthor : name : \"joe.bloggs\" email : \"joe.bloggs@gmail.com\" commitMessage : \"chore(release): a custom release message\" Uplift uses your GPG Identity If you have imported a GPG key, Uplift will always use the keys user identity over any other configuration","title":"Changing the Commit Details"},{"location":"setup/config-location/","text":"Changing the default Config Location \u00b6 Uplift will look for a config file in the root of your repository. If you wish to change this location, you can use the --config-dir flag. uplift release --config-dir .github","title":"Changing Location of Config"},{"location":"setup/config-location/#changing-the-default-config-location","text":"Uplift will look for a config file in the root of your repository. If you wish to change this location, you can use the --config-dir flag. uplift release --config-dir .github","title":"Changing the default Config Location"},{"location":"setup/dry-run/","text":"Run Uplift without making any Changes \u00b6 New to Uplift? Want to understand how it works? Then you have come to the right place. Use the --dry-run flag with any command and Uplift will run in simulation mode and output precisely what would have changed. uplift release --dry-run If you want extra information, turn on debug mode with the --debug flag.","title":"Run without making Changes"},{"location":"setup/dry-run/#run-uplift-without-making-any-changes","text":"New to Uplift? Want to understand how it works? Then you have come to the right place. Use the --dry-run flag with any command and Uplift will run in simulation mode and output precisely what would have changed. uplift release --dry-run If you want extra information, turn on debug mode with the --debug flag.","title":"Run Uplift without making any Changes"},{"location":"setup/git-behaviour/","text":"Changing how Uplift works with Git \u00b6 Sometimes you will find Uplift will complain about the current git repository, and in most situations, it is for the right reason. If you wish to override this behaviour, you can customise how Uplift interacts with git. It is worth pointing out that you cannot make Uplift run against a dirty repository, and you will have to fix that yourself using our handy FAQ . Ignoring a Detached HEAD \u00b6 Either use the --ignore-detached flag: uplift release --ignore-detached Or include the following entry in your config file: 1 2 3 4 # .uplift.yml git : ignoreDetached : true Ignoring a Shallow Clone \u00b6 Either use the --ignore-shallow flag: uplift release --ignore-shallow Or include the following entry in your config file: 1 2 3 4 # .uplift.yml git : ignoreShallow : true","title":"Configuring Git Behaviour"},{"location":"setup/git-behaviour/#changing-how-uplift-works-with-git","text":"Sometimes you will find Uplift will complain about the current git repository, and in most situations, it is for the right reason. If you wish to override this behaviour, you can customise how Uplift interacts with git. It is worth pointing out that you cannot make Uplift run against a dirty repository, and you will have to fix that yourself using our handy FAQ .","title":"Changing how Uplift works with Git"},{"location":"setup/git-behaviour/#ignoring-a-detached-head","text":"Either use the --ignore-detached flag: uplift release --ignore-detached Or include the following entry in your config file: 1 2 3 4 # .uplift.yml git : ignoreDetached : true","title":"Ignoring a Detached HEAD"},{"location":"setup/git-behaviour/#ignoring-a-shallow-clone","text":"Either use the --ignore-shallow flag: uplift release --ignore-shallow Or include the following entry in your config file: 1 2 3 4 # .uplift.yml git : ignoreShallow : true","title":"Ignoring a Shallow Clone"},{"location":"setup/hooks/","text":"Extending Uplift with Hooks \u00b6 Uplift can be extended through the use of hooks. A hook is a specific point during a workflow where Uplift executes adhoc shell commands and scripts. If you need to print the output from any command or script, use the --debug flag. before : a hook that executes before any tasks within the workflow after : a hook that executes after completing all workflow tasks beforeBump : a hook that executes before bumping any configured files afterBump : a hook that executes after bumping all configured files beforeChangelog : a hook that executes before generating a changelog afterChangelog : a hook that executes after changelog generation beforeTag : a hook that executes before tagging the repository afterTag : a hook that executes after the repository is tagged 1 2 3 4 5 6 7 # .uplift.yml hooks : before : - cargo fetch - ENV=VALUE ./my-custom-script.sh - bash path//to//my-custom-script.sh # (1) An example of invoking a script using a POSIX-based Windows shell. Pay special attention to the use of // when specifying a path \u2764\ufe0f to the github.com/mvdan/sh library. Injecting Environment Variables \u00b6 Extend hook support by defining environment variables that Uplift will inject into the runtime environment. Either list environment variables individually or import them through dotenv (.env) files. Uplift will merge all environment variables with any pre-existing system ones. 1 2 3 4 5 6 7 # .uplift.yml env : - VARIABLE=VALUE - ANOTHER_VARIABLE=ANOTHER VALUE - .env - path/to/other.env \u2764\ufe0f to the github.com/joho/godotenv library.","title":"Extending Uplift with Hooks"},{"location":"setup/hooks/#extending-uplift-with-hooks","text":"Uplift can be extended through the use of hooks. A hook is a specific point during a workflow where Uplift executes adhoc shell commands and scripts. If you need to print the output from any command or script, use the --debug flag. before : a hook that executes before any tasks within the workflow after : a hook that executes after completing all workflow tasks beforeBump : a hook that executes before bumping any configured files afterBump : a hook that executes after bumping all configured files beforeChangelog : a hook that executes before generating a changelog afterChangelog : a hook that executes after changelog generation beforeTag : a hook that executes before tagging the repository afterTag : a hook that executes after the repository is tagged 1 2 3 4 5 6 7 # .uplift.yml hooks : before : - cargo fetch - ENV=VALUE ./my-custom-script.sh - bash path//to//my-custom-script.sh # (1) An example of invoking a script using a POSIX-based Windows shell. Pay special attention to the use of // when specifying a path \u2764\ufe0f to the github.com/mvdan/sh library.","title":"Extending Uplift with Hooks"},{"location":"setup/hooks/#injecting-environment-variables","text":"Extend hook support by defining environment variables that Uplift will inject into the runtime environment. Either list environment variables individually or import them through dotenv (.env) files. Uplift will merge all environment variables with any pre-existing system ones. 1 2 3 4 5 6 7 # .uplift.yml env : - VARIABLE=VALUE - ANOTHER_VARIABLE=ANOTHER VALUE - .env - path/to/other.env \u2764\ufe0f to the github.com/joho/godotenv library.","title":"Injecting Environment Variables"},{"location":"setup/print-tags/","text":"Printing Repository Tags \u00b6 Uplift provides utility functions for printing the current or next calculated semantic version of your repository to stdout . Useful if you want to use Uplift alongside other tools in your CI. Printing the Next Tag \u00b6 Scans all commits from the latest release 1 and prints the next calculated semantic version to stdout . Prints an empty string if no commits exist that triggers the next semantic version. NEXT_TAG = $( uplift tag --next --silent ) Printing the Current Tag \u00b6 Scans and prints the most recent semantic version from a repository with existing git tags to stdout . Prints an empty string if no tags exist. CURRENT_TAG = $( uplift tag --current ) Printing the Tag Transition \u00b6 Scans all commits from the latest release 1 and prints the current and next calculated semantic version to stdout . Both tags are separated by one whitespace ensuring compatibility with many Linux text processing tools, e.g. v0.1.0 v0.2.0 . Prints an empty string if no commits exist that triggers the next semantic version. TAG_TRANSITION = $( uplift tag --current --next --silent ) If this is a repository without any previous releases, Uplift will scan the entire commit history \u21a9 \u21a9","title":"Printing Repository Tags"},{"location":"setup/print-tags/#printing-repository-tags","text":"Uplift provides utility functions for printing the current or next calculated semantic version of your repository to stdout . Useful if you want to use Uplift alongside other tools in your CI.","title":"Printing Repository Tags"},{"location":"setup/print-tags/#printing-the-next-tag","text":"Scans all commits from the latest release 1 and prints the next calculated semantic version to stdout . Prints an empty string if no commits exist that triggers the next semantic version. NEXT_TAG = $( uplift tag --next --silent )","title":"Printing the Next Tag"},{"location":"setup/print-tags/#printing-the-current-tag","text":"Scans and prints the most recent semantic version from a repository with existing git tags to stdout . Prints an empty string if no tags exist. CURRENT_TAG = $( uplift tag --current )","title":"Printing the Current Tag"},{"location":"setup/print-tags/#printing-the-tag-transition","text":"Scans all commits from the latest release 1 and prints the current and next calculated semantic version to stdout . Both tags are separated by one whitespace ensuring compatibility with many Linux text processing tools, e.g. v0.1.0 v0.2.0 . Prints an empty string if no commits exist that triggers the next semantic version. TAG_TRANSITION = $( uplift tag --current --next --silent ) If this is a repository without any previous releases, Uplift will scan the entire commit history \u21a9 \u21a9","title":"Printing the Tag Transition"},{"location":"setup/silent/","text":"Silencing all Output \u00b6 If you want to stop all logging when running any Uplift command, use the --silent flag. uplift release --silent","title":"Silencing all Output"},{"location":"setup/silent/#silencing-all-output","text":"If you want to stop all logging when running any Uplift command, use the --silent flag. uplift release --silent","title":"Silencing all Output"}]}